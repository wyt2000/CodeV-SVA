{"name": "FVEval-NL2SVA-Machine-0", "problem": "Both sig_F and sig_H are high, or all bits of sig_I are high, or sig_B is high.", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F,\n    input sig_H,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_F && sig_H) || &sig_I) || sig_B)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_F,sig_H,sig_I"}
{"name": "FVEval-NL2SVA-Machine-1", "problem": "The value of sig_C not being equal to the bitwise NOR reduction of sig_D, checked for equality with sig_A, differs from the logical AND between sig_J and sig_I", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_I,\n    input sig_J,\n    input [3:0] sig_A,\n    input [3:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_C !== ~|sig_D) === sig_A) !== (sig_J && sig_I))\n);", "multi_bit_signals": "sig_D sig_A", "signal_list": "sig_C,sig_I,sig_J,[3:0] sig_A,[3:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-2", "problem": "If both sig_G and sig_C are high and sig_A is high, then sig_I must not be high 5 clock cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input sig_G,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G && (sig_C && sig_A)) |-> ##5 !sig_I\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_C,sig_G,sig_I"}
{"name": "FVEval-NL2SVA-Machine-3", "problem": "It is never the case that sig_C is equal to the logical AND of sig_A and sig_H", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_C != (sig_A && sig_H)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_C,sig_H"}
{"name": "FVEval-NL2SVA-Machine-4", "problem": "The value of (sig_H being equal to sig_F) must differ from the value of sig_J", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_F,\n    input [4:0] sig_H,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_H === sig_F) !== sig_J)\n);", "multi_bit_signals": "sig_H sig_F sig_J", "signal_list": "[4:0] sig_F,[4:0] sig_H,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-6", "problem": "sig_F must not be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F !== 1'b1)\n);", "multi_bit_signals": "sig_F", "signal_list": "[4:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-7", "problem": "If sig_G is high, then between 5 to 9 clock cycles later, (sig_J being different from sig_E) must not be equivalent to (sig_H being different from sig_B)", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [3:0] sig_B,\n    input [3:0] sig_E,\n    input [3:0] sig_H,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> ##[5:9] ((sig_J !== sig_E) !== (sig_H !== sig_B))\n);", "multi_bit_signals": "sig_J sig_E sig_H sig_B", "signal_list": "sig_G,[3:0] sig_B,[3:0] sig_E,[3:0] sig_H,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-8", "problem": "If the bitwise XOR of sig_F and the reduction XOR of sig_A equals sig_H, then the bitwise XOR of sig_G and the reduction OR of sig_C must be 1'b1, and either sig_H or sig_J must be 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [7:0] sig_A,\n    input [7:0] sig_C,\n    input [7:0] sig_F,\n    input [7:0] sig_H,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ((sig_F ^ (^sig_A)) == sig_H) |-> \n    ((sig_G ^ (|sig_C) == 1'b1) && (sig_H == 1'b1 || sig_J == 1'b1))\n);", "multi_bit_signals": "sig_F sig_A sig_H sig_C sig_J", "signal_list": "sig_G,[7:0] sig_A,[7:0] sig_C,[7:0] sig_F,[7:0] sig_H,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-9", "problem": "If sig_C is not 1, then sig_F should be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    !sig_C |-> sig_F\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_F"}
{"name": "FVEval-NL2SVA-Machine-10", "problem": "Either sig_J is equal to sig_E or sig_C is true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [7:0] sig_E,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J === sig_E) || sig_C)\n);", "multi_bit_signals": "sig_J sig_E", "signal_list": "sig_C,[7:0] sig_E,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-11", "problem": "If sig_G and sig_J are both nonzero, then two clock cycles later, sig_G must have an odd number of 1s and all bits of sig_B must be 1", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_B,\n    input [6:0] sig_G,\n    input [6:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_G != 1'b0) && (sig_J != 1'b0)) |-> ##2 (^sig_G === 1'b1) && (&sig_B)\n);", "multi_bit_signals": "sig_G sig_J sig_B", "signal_list": "[6:0] sig_B,[6:0] sig_G,[6:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-12", "problem": "If sig_B is less than sig_A or sig_E is true, then one cycle later, sig_F must be equal to sig_A", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_B < sig_A) || sig_E) |-> ##1 (sig_F === sig_A)\n);", "multi_bit_signals": "sig_B sig_A sig_F", "signal_list": "sig_E,[3:0] sig_A,[3:0] sig_B,[3:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-13", "problem": "If sig_C is high, then sig_J will be high and sig_B will have no '1' bits in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_J,\n    input [3:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_C |=> (sig_J && ~|sig_B)\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_C,sig_J,[3:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-14", "problem": "sig_I is not equal to sig_G and sig_C is not 1", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_C,\n    input [3:0] sig_G,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I !== sig_G) && (sig_C !== 1'b1))\n);", "multi_bit_signals": "sig_I sig_G sig_C", "signal_list": "[3:0] sig_C,[3:0] sig_G,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-15", "problem": "If sig_C is true, then after three clock cycles, sig_B must not be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [4:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_C |-> ##3 (sig_B !== 1'b1)\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_C,[4:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-16", "problem": "sig_I is not equal to the bitwise NOR reduction of sig_C", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_C,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_I !== ~|sig_C)\n);", "multi_bit_signals": "sig_I sig_C", "signal_list": "[4:0] sig_C,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-17", "problem": "If sig_J is true, then sig_G must eventually become false", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> s_eventually(!sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_G,sig_J"}
{"name": "FVEval-NL2SVA-Machine-18", "problem": "If sig_G is not equal to 1'b1, then four cycles later, sig_J must be true", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [7:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G !== 1'b1) |-> ##4 sig_J\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_J,[7:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-19", "problem": "sig_A or the bitwise negation of sig_J, exclusive OR sig_D, is true at each rising clock edge", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_D,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ((sig_A | ~sig_J) ^ sig_D)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_D,sig_J"}
{"name": "FVEval-NL2SVA-Machine-20", "problem": "If sig_G is true, then eventually ((sig_C or sig_H has at least one '1' bit) XOR (sig_C XOR sig_I)) must be true", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [7:0] sig_C,\n    input [7:0] sig_H,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> s_eventually(((|sig_C || |sig_H) ^ (sig_C ^ sig_I)))\n);", "multi_bit_signals": "sig_C sig_H sig_I", "signal_list": "sig_G,[7:0] sig_C,[7:0] sig_H,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-21", "problem": "If sig_C is high or sig_D is low, then sig_J must be different from sig_E in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_D,\n    input [4:0] sig_E,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C || !sig_D) |=> (sig_J ^ sig_E)\n);", "multi_bit_signals": "sig_J sig_E", "signal_list": "sig_C,sig_D,[4:0] sig_E,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-22", "problem": "If sig_C is true and sig_F is greater than sig_A, then sig_F is not equal to sig_E", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [7:0] sig_A,\n    input [7:0] sig_E,\n    input [7:0] sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_C && (sig_F > sig_A)) |-> (sig_F != sig_E)\n);", "multi_bit_signals": "sig_F sig_A sig_E", "signal_list": "sig_C,[7:0] sig_A,[7:0] sig_E,[7:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-24", "problem": "sig_G and sig_E must both be high", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G && sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-25", "problem": "Either sig_G is high or both sig_D and sig_H are high, or either sig_A or sig_C is high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input sig_D,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_G || (sig_D && sig_H) || sig_A || sig_C)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_C,sig_D,sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-26", "problem": "sig_C is high or the exclusive OR between (sig_G not equal to sig_D) and sig_E is true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_E,\n    input [6:0] sig_D,\n    input [6:0] sig_G\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_C || ((sig_G != sig_D) ^ sig_E)\n);", "multi_bit_signals": "sig_G sig_D", "signal_list": "sig_C,sig_E,[6:0] sig_D,[6:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-27", "problem": "sig_H is high and the bitwise AND of sig_I and sig_F is equal to sig_B", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [7:0] sig_B,\n    input [7:0] sig_F,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H && ((sig_I & sig_F) === sig_B))\n);", "multi_bit_signals": "sig_I sig_F sig_B", "signal_list": "sig_H,[7:0] sig_B,[7:0] sig_F,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-28", "problem": "When sig_E is high and not all bits of sig_A are high, the value of sig_A must not be equal to sig_F", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input [5:0] sig_A,\n    input [5:0] sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_E && !(&sig_A)) |-> (sig_A != sig_F)\n);", "multi_bit_signals": "sig_A sig_F", "signal_list": "sig_E,[5:0] sig_A,[5:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-29", "problem": "When sig_D is true, sig_F must be true on the following clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_D |=> sig_F\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_F"}
{"name": "FVEval-NL2SVA-Machine-30", "problem": "If sig_H is true, then sig_A must not be equal to 1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [4:0] sig_A\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |-> (sig_A !== 1'b1)\n);", "multi_bit_signals": "sig_A", "signal_list": "sig_H,[4:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-31", "problem": "sig_A and sig_E are different, and sig_C is equal to sig_H", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_A,\n    input [6:0] sig_C,\n    input [6:0] sig_E,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_A != sig_E) && (sig_C == sig_H)\n);", "multi_bit_signals": "sig_A sig_E sig_C sig_H", "signal_list": "[6:0] sig_A,[6:0] sig_C,[6:0] sig_E,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-32", "problem": "If sig_F is true and sig_A contains all '0' bits, then every bit of sig_J must eventually be '1'", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [5:0] sig_A,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F && ~|sig_A) |-> ##[0:$] (&sig_J)\n);", "multi_bit_signals": "sig_A sig_J", "signal_list": "sig_F,[5:0] sig_A,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-33", "problem": "If the inequality between sig_F and sig_A is different from sig_B, then two clock cycles later sig_D will be true", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_D,\n    input [5:0] sig_A,\n    input [5:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_F !== sig_A) !== sig_B) |-> ##2 sig_D\n);", "multi_bit_signals": "sig_F sig_A", "signal_list": "sig_B,sig_D,[5:0] sig_A,[5:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-34", "problem": "sig_C must not be the same as the value of sig_I XORed with whether sig_A is greater than or equal to sig_F", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_I,\n    input [4:0] sig_A,\n    input [4:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C !== (sig_I ^ (sig_A >= sig_F)))\n);", "multi_bit_signals": "sig_A sig_F", "signal_list": "sig_C,sig_I,[4:0] sig_A,[4:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-35", "problem": "If the exclusive OR of sig_E and sig_G is equal to the exclusive OR of sig_A and sig_J, then sig_C should at least one '0' bit and sig_F be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [4:0] sig_A,\n    input [4:0] sig_C,\n    input [4:0] sig_E,\n    input [4:0] sig_G,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_E ^ sig_G) === (sig_A ^ sig_J)) |=> (~&sig_C && sig_F)\n);", "multi_bit_signals": "sig_E sig_G sig_A sig_J sig_C", "signal_list": "sig_F,[4:0] sig_A,[4:0] sig_C,[4:0] sig_E,[4:0] sig_G,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-36", "problem": "If sig_F is different from whether sig_H is greater than sig_G, then it must always be true that sig_C is not equal to the exclusive OR of sig_J and sig_E", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [5:0] sig_C,\n    input [5:0] sig_E,\n    input [5:0] sig_G,\n    input [5:0] sig_H,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F != (sig_H > sig_G)) |-> always((sig_C !== (sig_J ^ sig_E)))\n);", "multi_bit_signals": "sig_H sig_G sig_C sig_J sig_E", "signal_list": "sig_F,[5:0] sig_C,[5:0] sig_E,[5:0] sig_G,[5:0] sig_H,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-37", "problem": "If either sig_G or sig_E is true, then sig_G must be true after 4 clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G || sig_E) |-> ##4 sig_G\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-38", "problem": "If sig_H is true, then the logical XOR of (sig_F OR sig_J) with sig_E must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_H,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |=> ((sig_F | sig_J) ^ sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_F,sig_H,sig_J"}
{"name": "FVEval-NL2SVA-Machine-39", "problem": "If sig_C is not equal to the logical AND of all bits in sig_I, then sig_G must be true in the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [6:0] sig_C,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C !== &sig_I) |=> sig_G\n);", "multi_bit_signals": "sig_C sig_I", "signal_list": "sig_G,[6:0] sig_C,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-40", "problem": "The results of the following two logical operations are different:\n1. sig_I is true, and exactly one of sig_B and sig_H is true.\n2. sig_A is true, and exactly one of sig_F and sig_B is true.", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_B,\n    input sig_F,\n    input sig_H,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_B ^ sig_H) && sig_I) != ((sig_F ^ sig_B) && sig_A))\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_B,sig_F,sig_H,sig_I"}
{"name": "FVEval-NL2SVA-Machine-41", "problem": "If sig_G is not the complement of sig_F, then sig_I must eventually be less than sig_H", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_F,\n    input [5:0] sig_G,\n    input [5:0] sig_H,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G !== ~sig_F) |-> s_eventually((sig_I < sig_H))\n);", "multi_bit_signals": "sig_G sig_F sig_I sig_H", "signal_list": "[5:0] sig_F,[5:0] sig_G,[5:0] sig_H,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-42", "problem": "When sig_J is not equal to sig_D, the bitwise AND of sig_G and sig_I should not equal 1", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_D,\n    input [5:0] sig_G,\n    input [5:0] sig_I,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_J != sig_D) |-> ((sig_G & sig_I) != 1'b1)\n);", "multi_bit_signals": "sig_J sig_D sig_G sig_I", "signal_list": "[5:0] sig_D,[5:0] sig_G,[5:0] sig_I,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-43", "problem": "If sig_B is high or sig_H is true, then within 3 to 7 cycles, sig_D must be high and all bits of sig_A must not be high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_D,\n    input sig_H,\n    input [7:0] sig_A\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B || sig_H) |-> ##[3:7] (sig_D && ~|sig_A)\n);", "multi_bit_signals": "sig_A", "signal_list": "sig_B,sig_D,sig_H,[7:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-44", "problem": "Whenever sig_F transitions from high to low, sig_D must be high on the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    $fell(sig_F) |=> sig_D\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_F"}
{"name": "FVEval-NL2SVA-Machine-45", "problem": "Either sig_I or sig_F (or both) must be false", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_I && sig_F) != 1'b1\n);", "multi_bit_signals": "", "signal_list": "sig_F,sig_I"}
{"name": "FVEval-NL2SVA-Machine-46", "problem": "If sig_I is not equal to 1'b1, then sig_F or sig_D is high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_F,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_I != 1'b1) |-> (sig_F || sig_D)\n);", "multi_bit_signals": "sig_I", "signal_list": "sig_D,sig_F,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-48", "problem": "If sig_J has an odd number of '1' bits or sig_H is true, then on the next cycle, sig_A must not be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [7:0] sig_A,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(^sig_J || sig_H) |-> ##1 (sig_A !== 1'b1)\n);", "multi_bit_signals": "sig_J sig_A", "signal_list": "sig_H,[7:0] sig_A,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-49", "problem": "If either sig_E or sig_F is high, sig_J must always contain all '1' bits", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E || sig_F) |-> always((&sig_J === 1'b1))\n);", "multi_bit_signals": "sig_J", "signal_list": "sig_E,sig_F,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-51", "problem": "sig_H and sig_B must always be high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\talways(sig_H && sig_B)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_H"}
{"name": "FVEval-NL2SVA-Machine-52", "problem": "sig_B or sig_F is high and sig_I contains at least one '1' bit", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_B || sig_F) && |sig_I)\n);", "multi_bit_signals": "sig_I", "signal_list": "sig_B,sig_F,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-53", "problem": "If sig_C and sig_I are both high, then one cycle later, sig_E and sig_I will have different values", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [7:0] sig_E,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C && sig_I) |-> ##1 (sig_E ^ sig_I)\n);", "multi_bit_signals": "sig_E sig_I", "signal_list": "sig_C,[7:0] sig_E,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-55", "problem": "Whenever sig_D is true and sig_E is less than sig_H, the exclusive OR of sig_B and sig_A must be true and sig_D must not be equal to sig_J", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_B,\n    input [5:0] sig_D,\n    input [5:0] sig_E,\n    input [5:0] sig_H,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_D && (sig_E < sig_H)) |-> ((sig_B ^ sig_A) && (sig_D != sig_J))\n);", "multi_bit_signals": "sig_E sig_H sig_D sig_J", "signal_list": "sig_A,sig_B,[5:0] sig_D,[5:0] sig_E,[5:0] sig_H,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-56", "problem": "If sig_D is equal to sig_G, or sig_D is true, then sig_F should not be high until at least one bit of sig_C is high", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [7:0] sig_C,\n    input [7:0] sig_D,\n    input [7:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_D === sig_G) || sig_D) |-> (sig_F !== 1'b1) until (|sig_C)\n);", "multi_bit_signals": "sig_D sig_G sig_C", "signal_list": "sig_F,[7:0] sig_C,[7:0] sig_D,[7:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-57", "problem": "sig_F must always equal the bitwise XOR of sig_I and sig_B", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_B,\n    input [5:0] sig_F,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F === (sig_I ^ sig_B))\n);", "multi_bit_signals": "sig_F sig_I sig_B", "signal_list": "[5:0] sig_B,[5:0] sig_F,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-58", "problem": "The AND reduction of sig_H is equal to sig_F", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_F,\n    input [7:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(&sig_H === sig_F)\n);", "multi_bit_signals": "sig_H sig_F", "signal_list": "[7:0] sig_F,[7:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-59", "problem": "sig_J, sig_B, sig_I, or sig_E is high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_E,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J || (sig_B || sig_I)) || sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_E,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-60", "problem": "If sig_G is not equal to the negation of sig_J, then sig_D must be true", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input [3:0] sig_G,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_G != ~sig_J) |-> sig_D\n);", "multi_bit_signals": "sig_G sig_J", "signal_list": "sig_D,[3:0] sig_G,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-61", "problem": "Either sig_D is high or sig_H has an odd number of bits set to '1', and sig_F is also high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_F,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_D || ^sig_H) && sig_F)\n);", "multi_bit_signals": "sig_H", "signal_list": "sig_D,sig_F,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-62", "problem": "The bitwise-XOR of (sig_G and the bitwise-OR of sig_C and sig_I) must be equal to whether sig_D is equal to sig_F", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_C,\n    input [4:0] sig_D,\n    input [4:0] sig_F,\n    input [4:0] sig_G,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_C | sig_I) ^ sig_G) === (sig_D === sig_F))\n);", "multi_bit_signals": "sig_C sig_I sig_G sig_D sig_F", "signal_list": "[4:0] sig_C,[4:0] sig_D,[4:0] sig_F,[4:0] sig_G,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-63", "problem": "sig_F must be true, or sig_G must not be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [5:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F || (sig_G !== 1'b1))\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_F,[5:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-64", "problem": "sig_I is not 1 and sig_A is 1, or sig_I is 1 and sig_A is 0", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_I != 1'b1) && (sig_A == 1'b1) ) || ( (sig_I == 1'b1) && (sig_A == 1'b0) )\n);", "multi_bit_signals": "sig_I sig_A", "signal_list": "[3:0] sig_A,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-65", "problem": "sig_J must be equal sig_C", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_C,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J === sig_C)\n);", "multi_bit_signals": "sig_J sig_C", "signal_list": "[4:0] sig_C,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-66", "problem": "If sig_E is not equal to 1'b1, then two cycles later, either sig_I or sig_G must be true", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_I,\n    input [3:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E !== 1'b1) |-> ##2 (sig_I || sig_G)\n);", "multi_bit_signals": "sig_E", "signal_list": "sig_G,sig_I,[3:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-67", "problem": "Either sig_I is true or both sig_D and sig_I are true", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_I || (sig_D && sig_I))\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_I"}
{"name": "FVEval-NL2SVA-Machine-68", "problem": "If the comparison of sig_B being greater than sig_H is different from the XOR of sig_F and sig_J, then after 5 cycles, either sig_B is greater than zero or sig_D must contain at least one '1' bit or sig_C must be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [5:0] sig_B,\n    input [5:0] sig_D,\n    input [5:0] sig_F,\n    input [5:0] sig_H,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_B > sig_H) !== (sig_F ^ sig_J)) |-> ##5 ((sig_B > 0) || (|sig_D) || sig_C)\n);", "multi_bit_signals": "sig_B sig_H sig_F sig_J sig_D", "signal_list": "sig_C,[5:0] sig_B,[5:0] sig_D,[5:0] sig_F,[5:0] sig_H,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-69", "problem": "If (the bitwise AND of sig_J and sig_B) XORed with (the XOR of sig_F and sig_B), then sig_H is different from sig_D in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F,\n    input sig_J,\n    input [6:0] sig_D,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J & sig_B) ^ (sig_F ^ sig_B)) |=> (sig_H != sig_D)\n);", "multi_bit_signals": "sig_H sig_D", "signal_list": "sig_B,sig_F,sig_J,[6:0] sig_D,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-70", "problem": "If sig_H remains unchanged, then all bits of sig_D must be high", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_D,\n    input [5:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t$stable(sig_H) |-> &sig_D\n);", "multi_bit_signals": "sig_H sig_D", "signal_list": "[5:0] sig_D,[5:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-71", "problem": "If either sig_G or sig_A is true, then after exactly two clock cycles, sig_E will be false and sig_D will be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_D,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G || sig_A) |-> ##2 (!sig_E && sig_D)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_D,sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-72", "problem": "Whenever sig_G is true, sig_H must be true on the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |=> sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-73", "problem": "The bitwise OR reduction of sig_I must be equal to the bitwise OR reduction of sig_G", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_G,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(|sig_I === |sig_G)\n);", "multi_bit_signals": "sig_I sig_G", "signal_list": "[5:0] sig_G,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-74", "problem": "If sig_D is high, then sig_F must eventually become true", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_D |-> s_eventually(sig_F)\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_F"}
{"name": "FVEval-NL2SVA-Machine-75", "problem": "sig_I must be less than or equal to the result of a bitwise XOR operation between sig_D and the bitwise OR of sig_G and sig_H", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_D,\n    input [5:0] sig_G,\n    input [5:0] sig_H,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_I <= (sig_D ^ (sig_G | sig_H))\n);", "multi_bit_signals": "sig_I sig_D sig_G sig_H", "signal_list": "[5:0] sig_D,[5:0] sig_G,[5:0] sig_H,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-76", "problem": "sig_F is not 1 and sig_J is less than or equal to sig_H, or sig_F is 1 and sig_J is greater than sig_H", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [3:0] sig_H,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_F != 1'b1) && (sig_J <= sig_H) ) || ( (sig_F == 1'b1) && (sig_J > sig_H) )\n);", "multi_bit_signals": "sig_J sig_H", "signal_list": "sig_F,[3:0] sig_H,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-77", "problem": "If sig_B and sig_C are both high, then sig_H must be high within 1 to 4 clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B && sig_C) |-> ##[1:4] sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_C,sig_H"}
{"name": "FVEval-NL2SVA-Machine-78", "problem": "If sig_C is high and either sig_B or sig_I is high, then after 5 clock cycles, either sig_G or sig_J will be high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input sig_G,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C && (sig_B || sig_I)) |-> ##5 (sig_G || sig_J)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_C,sig_G,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-79", "problem": "If sig_D is high and sig_E is not equal to 1, then either sig_H or sig_G must eventually be high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_G,\n    input sig_H,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_D && sig_E != 1'b1) |-> ##[0:$] (sig_H || sig_G) )\n);", "multi_bit_signals": "sig_E", "signal_list": "sig_D,sig_G,sig_H,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-80", "problem": "When sig_E equals sig_F or sig_H is greater than sig_B, both sig_A and sig_E are high along with sig_D being high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_D,\n    input [4:0] sig_B,\n    input [4:0] sig_E,\n    input [4:0] sig_F,\n    input [4:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_E == sig_F) || (sig_H > sig_B) ) |-> (sig_A && sig_E && sig_D)\n);", "multi_bit_signals": "sig_E sig_F sig_H sig_B", "signal_list": "sig_A,sig_D,[4:0] sig_B,[4:0] sig_E,[4:0] sig_F,[4:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-81", "problem": "If sig_E is true, then one cycle later sig_A must be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_E |-> ##1 sig_A\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E"}
{"name": "FVEval-NL2SVA-Machine-82", "problem": "(Bitwise OR of sig_C and sig_E) must not be equivalent to (bitwise OR of sig_A and sig_D)", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_A,\n    input [6:0] sig_C,\n    input [6:0] sig_D,\n    input [6:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C | sig_E) !== (sig_D | sig_A)\n);", "multi_bit_signals": "sig_C sig_E sig_D sig_A", "signal_list": "[6:0] sig_A,[6:0] sig_C,[6:0] sig_D,[6:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-83", "problem": "sig_D is greater than sig_C or sig_E is low or sig_F is high, or sig_I is high", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_I,\n    input [6:0] sig_C,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_D > sig_C) || ((~sig_E || sig_F) || sig_I))\n);", "multi_bit_signals": "sig_D sig_C", "signal_list": "sig_E,sig_F,sig_I,[6:0] sig_C,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-84", "problem": "If sig_G is high, then sig_D must be high on the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> ##1 sig_D\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_G"}
{"name": "FVEval-NL2SVA-Machine-85", "problem": "If sig_H is high, then either sig_D or sig_G must be true", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |-> (sig_D || sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-86", "problem": "(Either sig_A is true or sig_H bitwise NOR'd with sig_G) must not be exactly equal to sig_I", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_I,\n    input [4:0] sig_G,\n    input [4:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t( sig_A || (~(sig_H | sig_G)) ) !== sig_I\n);", "multi_bit_signals": "sig_H sig_G", "signal_list": "sig_A,sig_I,[4:0] sig_G,[4:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-87", "problem": "If sig_C is equal to sig_H, then sig_E must not be high at the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input [5:0] sig_C,\n    input [5:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C === sig_H) |=> (sig_E !== 1'b1)\n);", "multi_bit_signals": "sig_C sig_H", "signal_list": "sig_E,[5:0] sig_C,[5:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-88", "problem": "sig_A must be true if and only if sig_F is not equal to sig_D", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input [3:0] sig_D,\n    input [3:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_F !== sig_D) === sig_A)\n);", "multi_bit_signals": "sig_F sig_D", "signal_list": "sig_A,[3:0] sig_D,[3:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-89", "problem": "sig_C must be equal to sig_A", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_A,\n    input [4:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C === sig_A)\n);", "multi_bit_signals": "sig_C sig_A", "signal_list": "[4:0] sig_A,[4:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-90", "problem": "Either sig_F, sig_E, or sig_H is true, and sig_A is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_F || sig_E) || sig_H) && sig_A)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E,sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-91", "problem": "If sig_F is high and sig_E differs from sig_F, then sig_A must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F && (sig_E ^ sig_F)) |=> sig_A\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E,sig_F"}
{"name": "FVEval-NL2SVA-Machine-92", "problem": "If sig_B are not equal to sig_H, then within 3 to 7 clock cycles, none of the bits in sig_F will be '1'", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_B,\n    input [6:0] sig_F,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B !== sig_H) |-> ##[3:7] ~|sig_F\n);", "multi_bit_signals": "sig_B sig_H sig_F", "signal_list": "[6:0] sig_B,[6:0] sig_F,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-93", "problem": "The condition where sig_J is less than the bitwise AND of sig_I and sig_G must not be true", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_G,\n    input [5:0] sig_I,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J < (sig_I & sig_G)) !== 1'b1)\n);", "multi_bit_signals": "sig_J sig_I sig_G", "signal_list": "[5:0] sig_G,[5:0] sig_I,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-94", "problem": "If the value of (sig_H being less than sig_A) is not equal to sig_G, then ((sig_C XOR the AND reduction of sig_D) XOR (sig_B OR sig_J)) must always be true", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_C,\n    input [3:0] sig_D,\n    input [3:0] sig_H,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_H < sig_A) !== sig_G) |-> always(((sig_C ^ &sig_D) ^ (sig_B || sig_J)))\n);", "multi_bit_signals": "sig_H sig_A sig_C sig_D sig_B sig_J", "signal_list": "sig_G,[3:0] sig_A,[3:0] sig_B,[3:0] sig_C,[3:0] sig_D,[3:0] sig_H,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-95", "problem": "sig_I not being equal to 1 must be different from the bitwise XNOR of all bits in sig_F", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_F,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I !== 1'b1) !== ~^sig_F)\n);", "multi_bit_signals": "sig_I sig_F", "signal_list": "[4:0] sig_F,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-96", "problem": "If sig_C is true, then after two clock cycles, sig_H must be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_C |-> ##2 sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_H"}
{"name": "FVEval-NL2SVA-Machine-97", "problem": "When sig_F is different from sig_C, sig_B will be low on the following clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input [5:0] sig_C,\n    input [5:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F !== sig_C) |-> ##1 !sig_B\n);", "multi_bit_signals": "sig_F sig_C", "signal_list": "sig_B,[5:0] sig_C,[5:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-98", "problem": "If the bitwise negation of sig_J is not equal to the negated XOR reduction of sig_F, then the logical XOR of sig_C and sig_G must be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_G,\n    input [4:0] sig_F,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(~sig_J !== (~^sig_F)) |-> (sig_C ^ sig_G)\n);", "multi_bit_signals": "sig_J sig_F", "signal_list": "sig_C,sig_G,[4:0] sig_F,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-99", "problem": "If sig_D is not equal to 1 or sig_A is false, then within 5 to 9 cycles, sig_G must be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_G,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_D !== 1'b1 || !sig_A) |-> ##[5:9] sig_G\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_A,sig_G,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-100", "problem": "If the bitwise NOR reduction of sig_J XORed with the bitwise NOR reduction of sig_C, XORed with sig_G, is true, then after exactly 4 clock cycles, both sig_A and sig_B will be high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_B,\n    input [6:0] sig_C,\n    input [6:0] sig_G,\n    input [6:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((~|sig_J ^ ~|sig_C) ^ sig_G) |-> ##4 (sig_A && sig_B)\n);", "multi_bit_signals": "sig_J sig_C sig_G", "signal_list": "sig_A,sig_B,[6:0] sig_C,[6:0] sig_G,[6:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-101", "problem": "Whenever sig_J is high and sig_D is equal to sig_C, then sig_H is high or sig_D is nonzero", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input sig_J,\n    input [6:0] sig_C,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J && (sig_D === sig_C)) |-> (sig_H || (sig_D != 1'b0))\n);", "multi_bit_signals": "sig_D sig_C", "signal_list": "sig_H,sig_J,[6:0] sig_C,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-102", "problem": "When sig_G is low, it must be true that (sig_A equals sig_G) is not equal to (sig_D and sig_G)", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_D,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    !sig_G |-> ((sig_A == sig_G) != (sig_D & sig_G))\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_D,sig_G"}
{"name": "FVEval-NL2SVA-Machine-103", "problem": "When (sig_A bitwise-OR sig_D) has the same value as (sig_F bitwise-OR sig_H), sig_C must be less than sig_J in the subsequent cycle", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_A,\n    input [5:0] sig_C,\n    input [5:0] sig_D,\n    input [5:0] sig_F,\n    input [5:0] sig_H,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A | sig_D) === (sig_F | sig_H)) |=> (sig_C < sig_J)\n);", "multi_bit_signals": "sig_A sig_D sig_F sig_H sig_C sig_J", "signal_list": "[5:0] sig_A,[5:0] sig_C,[5:0] sig_D,[5:0] sig_F,[5:0] sig_H,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-104", "problem": "If sig_G is true, then sig_E must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |=> sig_E\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-106", "problem": "If sig_E is high and either sig_H or sig_F is high, then sig_E will be high three clock cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E && (sig_H || sig_F)) |-> ##3 sig_E\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-107", "problem": "If sig_G is true, then sig_B must not contain all '1' bits in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [7:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |=> ~&sig_B\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_G,[7:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-108", "problem": "If sig_C is high and sig_H is different from sig_E, or if sig_C is low and sig_H is the same as sig_E, then sig_D must contain at least one '1' bit in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [7:0] sig_D,\n    input [7:0] sig_E,\n    input [7:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C ^ (sig_H === sig_E)) |=> |sig_D\n);", "multi_bit_signals": "sig_H sig_E sig_D", "signal_list": "sig_C,[7:0] sig_D,[7:0] sig_E,[7:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-109", "problem": "sig_G is less than or equal to sig_H or the exclusive NOR reduction of sig_F is true", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_F,\n    input [5:0] sig_G,\n    input [5:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_G <= sig_H) || (~^sig_F)\n);", "multi_bit_signals": "sig_G sig_H sig_F", "signal_list": "[5:0] sig_F,[5:0] sig_G,[5:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-110", "problem": "If (the bitwise OR reduction of sig_C) XOR (NOT sig_J) is true and sig_C is nonzero, then after one cycle, sig_F and sig_C will be both high", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_J,\n    input [7:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((|sig_C ^ !sig_J) && (sig_C != 1'b0)) |-> ##1 (sig_F && sig_C)\n);", "multi_bit_signals": "sig_C", "signal_list": "sig_F,sig_J,[7:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-111", "problem": "(sig_B is equal to sig_H) AND ((the bitwise NOR reduction of sig_C) XOR sig_A) equals 1", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_A,\n    input [6:0] sig_B,\n    input [6:0] sig_C,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_B === sig_H) & (~|sig_C ^ sig_A)) == 1'b1\n);", "multi_bit_signals": "sig_B sig_H sig_C sig_A", "signal_list": "[6:0] sig_A,[6:0] sig_B,[6:0] sig_C,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-112", "problem": "If sig_A transitions from high to low, then sig_I must not equal sig_B in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input [7:0] sig_B,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t$fell(sig_A) |=> (sig_I !== sig_B)\n);", "multi_bit_signals": "sig_I sig_B", "signal_list": "sig_A,[7:0] sig_B,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-113", "problem": "If sig_D is not equal to 1, then between 5 to 8 clock cycles later, the logic AND of sig_H and sig_E must differ from the logic AND of !sig_J and sig_F", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_H,\n    input sig_J,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D !== 1'b1) |-> ##[5:8] ((sig_H && sig_E) ^ (!sig_J && sig_F))\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_E,sig_F,sig_H,sig_J,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-114", "problem": "If sig_J is less than or equal to sig_I, then sig_A must be different from the result of (sig_H not equal to sig_J)", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_H,\n    input [5:0] sig_I,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_J <= sig_I) |-> (sig_A != (sig_H != sig_J))\n);", "multi_bit_signals": "sig_J sig_I", "signal_list": "sig_A,sig_H,[5:0] sig_I,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-115", "problem": "The values of sig_E and sig_I must always be different", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_E,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\talways(sig_E != sig_I)\n);", "multi_bit_signals": "sig_E sig_I", "signal_list": "[4:0] sig_E,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-116", "problem": "If (the value of sig_I is less than sig_A) is logically equivalent to sig_H being low, then sig_D will transition from high to low at the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_H,\n    input [4:0] sig_A,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I < sig_A) === !sig_H) |=> $fell(sig_D)\n);", "multi_bit_signals": "sig_I sig_A", "signal_list": "sig_D,sig_H,[4:0] sig_A,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-117", "problem": "sig_J is high or sig_E is less than sig_B", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [7:0] sig_B,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J || (sig_E < sig_B))\n);", "multi_bit_signals": "sig_E sig_B", "signal_list": "sig_J,[7:0] sig_B,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-118", "problem": "sig_D is not equal to sig_E", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_D,\n    input [6:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D !== sig_E)\n);", "multi_bit_signals": "sig_D sig_E", "signal_list": "[6:0] sig_D,[6:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-119", "problem": "Either sig_J or sig_E must be high, or both sig_B and sig_F must be high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_E,\n    input sig_F,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J || sig_E) || (sig_B && sig_F))\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_E,sig_F,sig_J"}
{"name": "FVEval-NL2SVA-Machine-120", "problem": "If sig_F is nonzero or sig_E is equal to sig_F, then two cycles later, sig_E must not be 1", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_E,\n    input [3:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_F != 1'b0) || (sig_E === sig_F)) |-> ##2 (sig_E !== 1'b1)\n);", "multi_bit_signals": "sig_E sig_F", "signal_list": "[3:0] sig_E,[3:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-122", "problem": "If sig_E is true, then it must always be that either sig_H is high or sig_F is high", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_E |-> always((sig_H || sig_F))\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-123", "problem": "If (the parity of the '1's in sig_B XORed that of sig_I) equals to sig_F, then sig_J should remain stable", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [4:0] sig_B,\n    input [4:0] sig_I,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t( ( (^sig_B) ^ (^sig_I) ) == sig_F) |-> $stable(sig_J)\n);", "multi_bit_signals": "sig_B sig_I sig_J", "signal_list": "sig_F,[4:0] sig_B,[4:0] sig_I,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-124", "problem": "sig_E is different from the value of sig_J", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_E,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E ^ sig_J)\n);", "multi_bit_signals": "sig_E sig_J", "signal_list": "[4:0] sig_E,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-125", "problem": "If sig_J is true, then between 5 to 8 cycles later, (the value of sig_E being less than or equal to sig_I) must differ from sig_F", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_J,\n    input [6:0] sig_E,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> ##[5:8] ((sig_E <= sig_I) !== sig_F)\n);", "multi_bit_signals": "sig_E sig_I", "signal_list": "sig_F,sig_J,[6:0] sig_E,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-126", "problem": "If sig_E is true, then three cycles later, the bitwise-XOR of (bitwise-NOT sig_I bitwise-OR sig_D) and (sig_H bitwise-XOR the bitwise-NOR reduction of sig_J) must be 1", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input [7:0] sig_D,\n    input [7:0] sig_H,\n    input [7:0] sig_I,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_E |-> ##3 ( ((~sig_I | sig_D) ^ (sig_H ^ ~(|sig_J))) == 1'b1 )\n);", "multi_bit_signals": "sig_I sig_D sig_H sig_J", "signal_list": "sig_E,[7:0] sig_D,[7:0] sig_H,[7:0] sig_I,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-127", "problem": "If sig_G is not equal to 1 or sig_D is equal to sig_E, then sig_J must not be all '1' bits eventually", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_D,\n    input [3:0] sig_E,\n    input [3:0] sig_G,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_G !== 1'b1) || (sig_D === sig_E)) |-> ##[0:$] (~&sig_J)\n);", "multi_bit_signals": "sig_G sig_D sig_E sig_J", "signal_list": "[3:0] sig_D,[3:0] sig_E,[3:0] sig_G,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-128", "problem": "The XOR of sig_E and sig_B must always equal sig_C", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_B,\n    input [6:0] sig_C,\n    input [6:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_E ^ sig_B) === sig_C)\n);", "multi_bit_signals": "sig_E sig_B sig_C", "signal_list": "[6:0] sig_B,[6:0] sig_C,[6:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-129", "problem": "If sig_H is greater than sig_B, then sig_D must be true on the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input [6:0] sig_B,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H > sig_B) |=> sig_D\n);", "multi_bit_signals": "sig_H sig_B", "signal_list": "sig_D,[6:0] sig_B,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-130", "problem": "Either sig_J is true, or sig_C has an odd number of 1's, or sig_A is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_J,\n    input [7:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J || ^sig_C) || sig_A)\n);", "multi_bit_signals": "sig_C", "signal_list": "sig_A,sig_J,[7:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-131", "problem": "If sig_F is true and sig_D has at least one '1' bit, then sig_E will be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_F && (|sig_D)) |=> sig_E\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_E,sig_F,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-132", "problem": "If either sig_G or sig_H is true, then sig_C must become true within 1 to 6 clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G || sig_H) |-> ##[1:6] sig_C\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-133", "problem": "sig_E must be not equal to 1'b1 if and only if sig_B is false", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input [5:0] sig_E\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_E != 1'b1) == (!sig_B)\n);", "multi_bit_signals": "sig_E", "signal_list": "sig_B,[5:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-134", "problem": "sig_D must be high or both sig_E and sig_J must be high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_E,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D || (sig_E && sig_J))\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_E,sig_J"}
{"name": "FVEval-NL2SVA-Machine-135", "problem": "If sig_A equals to the negation of sig_C, then sig_J must equal sig_A in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_A === !sig_C) |=> (sig_J === sig_A)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_C,sig_J"}
{"name": "FVEval-NL2SVA-Machine-136", "problem": "If sig_B is true, then sig_F must be true in the following cycle", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_B |=> sig_F\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_F"}
{"name": "FVEval-NL2SVA-Machine-138", "problem": "sig_I or sig_J is true", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_I || sig_J)\n);", "multi_bit_signals": "", "signal_list": "sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-139", "problem": "If sig_C is high and not all bits in sig_A are high, in the next cycle, sig_G and sig_I must either both be high or both not be high", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_G,\n    input sig_I,\n    input [5:0] sig_A\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_C && !(&sig_A)) |=> (sig_G == sig_I)\n);", "multi_bit_signals": "sig_A", "signal_list": "sig_C,sig_G,sig_I,[5:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-140", "problem": "If sig_D is true, then either sig_E must be true or sig_J must be less than or equal to sig_B in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_E,\n    input [5:0] sig_B,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_D |=> (sig_E || (sig_J <= sig_B))\n);", "multi_bit_signals": "sig_J sig_B", "signal_list": "sig_D,sig_E,[5:0] sig_B,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-141", "problem": "sig_J is all zeroes or sig_D is all ones, or both sig_I and sig_B are true", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_I,\n    input [3:0] sig_D,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((~|sig_J || &sig_D) || (sig_I && sig_B))\n);", "multi_bit_signals": "sig_J sig_D", "signal_list": "sig_B,sig_I,[3:0] sig_D,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-142", "problem": "sig_D XOR sig_F must never be equal to 1", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_D,\n    input [5:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_D ^ sig_F) !== 1'b1)\n);", "multi_bit_signals": "sig_D sig_F", "signal_list": "[5:0] sig_D,[5:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-143", "problem": "sig_F and sig_G must be high", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F && sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_F,sig_G"}
{"name": "FVEval-NL2SVA-Machine-144", "problem": "(sig_C being true and sig_F containing at least one '1' bit) must be in opposite states to (sig_D not being 1 and sig_B being true)", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input [4:0] sig_D,\n    input [4:0] sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_C && |sig_F) != ( (sig_D != 1) && sig_B ) )\n);", "multi_bit_signals": "sig_F sig_D", "signal_list": "sig_B,sig_C,[4:0] sig_D,[4:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-145", "problem": "If sig_D becomes high, then after 5 clock cycles, sig_J must be high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_D |-> ##5 sig_J\n);", "multi_bit_signals": "", "signal_list": "sig_D,sig_J"}
{"name": "FVEval-NL2SVA-Machine-146", "problem": "If sig_A is different from sig_B, then sig_H must be equal to sig_A in the next cycle", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_A != sig_B) |=> (sig_H === sig_A)\n);", "multi_bit_signals": "sig_A sig_B sig_H", "signal_list": "[3:0] sig_A,[3:0] sig_B,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-147", "problem": " `sig_J` is not equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J !== 1'b1)\n);", "multi_bit_signals": "sig_J", "signal_list": "[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-148", "problem": "Either sig_C or sig_H is high, but not both", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C ^ sig_H)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_H"}
{"name": "FVEval-NL2SVA-Machine-149", "problem": "sig_G not equal to 1 or sig_H high implies that in the next cycle, sig_D is low and none of the bits in sig_J are high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_H,\n    input sig_J,\n    input [4:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_G !== 1'b1) || sig_H) |=> (!sig_D && ~|sig_J)\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_D,sig_H,sig_J,[4:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-150", "problem": "If sig_A is high, then within 1 to 3 cycles, either all bits of sig_C will be high or sig_H will be high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_H,\n    input [7:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_A |-> ##[1:3] (&sig_C || sig_H)\n);", "multi_bit_signals": "sig_C", "signal_list": "sig_A,sig_H,[7:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-151", "problem": "If (sig_H is not equal to '1') bitwise-XOR (sig_F bitwise-OR sig_A) is true, then sig_F must not be equal to '1' in the next cycle", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_F,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_H !== 1'b1) ^ (sig_F | sig_A)) |=> (sig_F !== 1'b1)\n);", "multi_bit_signals": "sig_H sig_F sig_A", "signal_list": "[3:0] sig_A,[3:0] sig_F,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-152", "problem": "If sig_C is true, then sig_I being not equal to 1'b1 must be the same as sig_J", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_J,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_C |-> ((sig_I !== 1'b1) === sig_J)\n);", "multi_bit_signals": "sig_I", "signal_list": "sig_C,sig_J,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-153", "problem": "sig_D must always never be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\talways(sig_D !== 1'b1)\n);", "multi_bit_signals": "sig_D", "signal_list": "[7:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-154", "problem": "sig_B must be true if and only if the exclusive OR of (sig_C not equal to sig_B) and sig_E is true", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input sig_E\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_B == ((sig_C != sig_B) ^ sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_C,sig_E"}
{"name": "FVEval-NL2SVA-Machine-155", "problem": "The value of sig_H must be equal to the expression where (the inequality comparison of sig_F and 1'b1) is XORed with (the AND result of (the XOR of sig_C and sig_I) and (the inequality comparison of the bitwise negation of sig_E and sig_A))", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [4:0] sig_A,\n    input [4:0] sig_C,\n    input [4:0] sig_E,\n    input [4:0] sig_F,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_H == ((sig_F != 1'b1) ^ ((sig_C ^ sig_I) & ((~sig_E) != sig_A)))\n);", "multi_bit_signals": "sig_F sig_C sig_I sig_E sig_A", "signal_list": "sig_H,[4:0] sig_A,[4:0] sig_C,[4:0] sig_E,[4:0] sig_F,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-156", "problem": "If sig_H is high, it must be followed by sig_A not being equal to 1'b1 eventually", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [4:0] sig_A\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |-> strong(##[0:$] (sig_A !== 1'b1))\n);", "multi_bit_signals": "sig_A", "signal_list": "sig_H,[4:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-157", "problem": "If either sig_H or sig_J is high, then after four clock cycles, sig_I must be high and sig_C must be less than or equal to sig_E", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input sig_I,\n    input sig_J,\n    input [5:0] sig_C,\n    input [5:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H || sig_J) |-> ##4 (sig_I && (sig_C <= sig_E))\n);", "multi_bit_signals": "sig_C sig_E", "signal_list": "sig_H,sig_I,sig_J,[5:0] sig_C,[5:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-158", "problem": "If not all bits of sig_G are 1, then sig_H must be high after two clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [4:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t~&sig_G |-> ##2 sig_H\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_H,[4:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-159", "problem": "sig_H must be low and sig_G must be high", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(~sig_H && sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-160", "problem": "If sig_I is low, then four cycles later, sig_E and the bitwise-NOR reduction of sig_A should not equal to 1", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input [7:0] sig_A,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t!sig_I |-> ##4 ( (sig_E != 1'b1) && (~|sig_A != 1'b1) )\n);", "multi_bit_signals": "sig_E sig_A", "signal_list": "sig_I,[7:0] sig_A,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-161", "problem": "If sig_H is true, then five clock cycles later, sig_D must not be equal to 1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [3:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |-> ##5 (sig_D !== 1'b1)\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_H,[3:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-162", "problem": "If sig_J is not 1 at a given time, then sig_C must be true between 4 to 6 cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J !== 1'b1) |-> ##[4:6] sig_C\n);", "multi_bit_signals": "sig_J", "signal_list": "sig_C,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-163", "problem": "sig_B must not be equal to sig_D", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_B,\n    input [5:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B !== sig_D)\n);", "multi_bit_signals": "sig_B sig_D", "signal_list": "[5:0] sig_B,[5:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-164", "problem": "If sig_D is not logic high, then either sig_E must be high or all bits of sig_F must be high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_E,\n    input [6:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D !== 1'b1) |-> (sig_E || &sig_F)\n);", "multi_bit_signals": "sig_F", "signal_list": "sig_D,sig_E,[6:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-165", "problem": "Whenever both sig_F and sig_E are high, and sig_J is high, either sig_C or sig_E must be high", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_E,\n    input sig_F,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_F && sig_E && sig_J) |-> (sig_C || sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_E,sig_F,sig_J"}
{"name": "FVEval-NL2SVA-Machine-166", "problem": "If sig_A and sig_G are both true, then within 1 to 6 cycles, either sig_E or sig_G will be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_A && sig_G) |-> ##[1:6] (sig_E || sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-167", "problem": "sig_C, sig_J, and sig_H together have an odd number of '1' bits.", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_C,\n    input [5:0] sig_H,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(^sig_C) ^ (^sig_J) ^ (^sig_H)\n);", "multi_bit_signals": "sig_C sig_J sig_H", "signal_list": "[5:0] sig_C,[5:0] sig_H,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-168", "problem": "If sig_E is not equal to 1, then sig_H must be true", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_E,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_E != 1'b1) |-> sig_H\n);", "multi_bit_signals": "sig_E sig_H", "signal_list": "[5:0] sig_E,sig_H"}
{"name": "FVEval-NL2SVA-Machine-169", "problem": "If sig_E, sig_J, and sig_I are all high, then sig_A must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_E && sig_J) && sig_I) |=> sig_A\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-170", "problem": "If sig_F is low and both sig_H is low and sig_I is high, three cycles later sig_C must have an odd number of 1 bits", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_H,\n    input sig_I,\n    input [3:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((~sig_F && (~sig_H && sig_I)) |-> ##3 (^sig_C))\n);", "multi_bit_signals": "sig_C", "signal_list": "sig_F,sig_H,sig_I,[3:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-171", "problem": "If sig_E is different from sig_C, then sig_D must eventually become true", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input [4:0] sig_C,\n    input [4:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E !== sig_C) |-> s_eventually(sig_D)\n);", "multi_bit_signals": "sig_E sig_C", "signal_list": "sig_D,[4:0] sig_C,[4:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-172", "problem": "If sig_F becomes true, then sig_H must be true five cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_F |-> ##5 sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-173", "problem": "sig_D must not be equal to the bitwise XOR of sig_A and sig_B", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_D\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_D != (sig_A ^ sig_B)\n);", "multi_bit_signals": "sig_D sig_A sig_B", "signal_list": "[3:0] sig_A,[3:0] sig_B,[3:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-174", "problem": "sig_J contains all '0' bits and sig_C is low, or sig_A contains all '0' bits", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [3:0] sig_A,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((~|sig_J && !sig_C) || ~|sig_A)\n);", "multi_bit_signals": "sig_J sig_A", "signal_list": "sig_C,[3:0] sig_A,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-175", "problem": "If sig_G is equal to the logical AND of all bits of sig_F, then sig_E must have been true four clock cycles ago", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G,\n    input [6:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G === &sig_F) |-> $past(sig_E, 4)\n);", "multi_bit_signals": "sig_F", "signal_list": "sig_E,sig_G,[6:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-177", "problem": "If not all bits of sig_E are high, then sig_J must be greater than the logical inversion of sig_G", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_E,\n    input [3:0] sig_G,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t~&sig_E |-> (sig_J > (~sig_G))\n);", "multi_bit_signals": "sig_E sig_J sig_G", "signal_list": "[3:0] sig_E,[3:0] sig_G,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-178", "problem": "If sig_G  is the same as sig_I, then sig_F must not be high at the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [7:0] sig_G,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G == sig_I) |=> (sig_F !== 1'b1)\n);", "multi_bit_signals": "sig_G sig_I", "signal_list": "sig_F,[7:0] sig_G,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-179", "problem": "sig_J is not equal to sig_G", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_G,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J != sig_G)\n);", "multi_bit_signals": "sig_J sig_G", "signal_list": "[4:0] sig_G,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-180", "problem": "If both sig_A and sig_F are high, then sig_B must also be high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_B,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_A && sig_F) |-> sig_B\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_B,sig_F"}
{"name": "FVEval-NL2SVA-Machine-181", "problem": "If sig_I is true, then sig_A must be true between 4 and 9 cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_I |-> ##[4:9] sig_A\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_I"}
{"name": "FVEval-NL2SVA-Machine-182", "problem": "If sig_H is equal to sig_D, then sig_E and sig_J will both be true on the subsequent clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input sig_J,\n    input [7:0] sig_D,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H === sig_D) |=> (sig_E && sig_J)\n);", "multi_bit_signals": "sig_E sig_D", "signal_list": "sig_H,sig_J,[7:0] sig_D,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-183", "problem": "Either sig_B or sig_F must be true", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B || sig_F)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_F"}
{"name": "FVEval-NL2SVA-Machine-184", "problem": "sig_H must be true when sig_G is not equal to 1'b1 and false when sig_G is equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [5:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H === (sig_G !== 1'b1))\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_H,[5:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-186", "problem": "sig_I and sig_E must never be true simultaneously", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I && sig_E) !== 1'b1)\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_I"}
{"name": "FVEval-NL2SVA-Machine-187", "problem": "sig_F is not equal to sig_C, or sig_F is high", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_F !== sig_C) || sig_F )\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_F"}
{"name": "FVEval-NL2SVA-Machine-188", "problem": "If either sig_B is true or sig_H is not equal to sig_A, then sig_E will transition from high to low in the following cycle", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_E,\n    input [6:0] sig_A,\n    input [6:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B || (sig_H != sig_A)) |=> $fell(sig_E)\n);", "multi_bit_signals": "sig_H sig_A", "signal_list": "sig_B,sig_E,[6:0] sig_A,[6:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-189", "problem": "If sig_B is true, then sig_I must become true between 4 to 8 cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_B |-> ##[4:8] sig_I\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_I"}
{"name": "FVEval-NL2SVA-Machine-190", "problem": "sig_E is greater than sig_D", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_D,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_E > sig_D\n);", "multi_bit_signals": "sig_E sig_D", "signal_list": "[7:0] sig_D,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-191", "problem": "sig_H must have an even number of bits set to '1'", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t^sig_H !== 1'b1\n);", "multi_bit_signals": "sig_H", "signal_list": "[4:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-192", "problem": "If sig_F is true, then sig_A must be true at a time between 4 to 6 cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_F |-> ##[4:6] sig_A\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_F"}
{"name": "FVEval-NL2SVA-Machine-193", "problem": "If sig_A is not equal to sig_B, then sig_A and sig_F must both be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [6:0] sig_A,\n    input [6:0] sig_B\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_A != sig_B) |=> (sig_A && sig_F)\n);", "multi_bit_signals": "sig_A sig_B", "signal_list": "sig_F,[6:0] sig_A,[6:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-194", "problem": "If sig_E and sig_D are different, then sig_I must be high or sig_F must be low in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_I,\n    input [5:0] sig_D,\n    input [5:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E ^ sig_D) |=> (sig_I || ~sig_F)\n);", "multi_bit_signals": "sig_E sig_D", "signal_list": "sig_F,sig_I,[5:0] sig_D,[5:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-195", "problem": "sig_F has an odd number of 1's and sig_J is low when all bits of sig_C are high", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [6:0] sig_C,\n    input [6:0] sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (&sig_C) |-> ((^sig_F) && !sig_J)\n);", "multi_bit_signals": "sig_F sig_C", "signal_list": "sig_J,[6:0] sig_C,[6:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-196", "problem": "sig_F must not be equal to the equivalence check between sig_H and sig_J", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [7:0] sig_H,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F !== (sig_H === sig_J))\n);", "multi_bit_signals": "sig_H sig_J", "signal_list": "sig_F,[7:0] sig_H,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-197", "problem": "If sig_A is equal to sig_C, then sig_D must be true within the next 1 to 4 cycles", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input [6:0] sig_A,\n    input [6:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_A === sig_C) |-> ##[1:4] sig_D\n);", "multi_bit_signals": "sig_A sig_C", "signal_list": "sig_D,[6:0] sig_A,[6:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-199", "problem": "If either sig_A or sig_C is true and both sig_I and sig_D are true, then either sig_F or sig_H must be true exactly two cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input sig_D,\n    input sig_F,\n    input sig_H,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A || sig_C) && (sig_I && sig_D)) |-> ##2 (sig_F || sig_H)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_C,sig_D,sig_F,sig_H,sig_I"}
{"name": "FVEval-NL2SVA-Machine-200", "problem": "If sig_B is high, then sig_H will be high one cycle later", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_B |-> ##1 sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_H"}
{"name": "FVEval-NL2SVA-Machine-201", "problem": "If sig_F or sig_A is true, then within 1 to 5 cycles, either sig_H is not equal to sig_J or sig_F is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_F,\n    input [4:0] sig_H,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_F || sig_A) |-> ##[1:5] (sig_H != sig_J || sig_F)\n);", "multi_bit_signals": "sig_H sig_J", "signal_list": "sig_A,sig_F,[4:0] sig_H,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-202", "problem": "If no bit in sig_C is '1', then either sig_J must equal sig_H, or (sig_E or sig_G) must eventually become true", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G,\n    input [3:0] sig_C,\n    input [3:0] sig_H,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t~|sig_C |-> ((sig_J == sig_H) or s_eventually (sig_E || sig_G))\n);", "multi_bit_signals": "sig_C sig_J sig_H", "signal_list": "sig_E,sig_G,[3:0] sig_C,[3:0] sig_H,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-203", "problem": "sig_F is nonzero and the bitwise OR of sig_F equals the bitwise negation of the bitwise OR of sig_I", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_F,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F != 1'b0) && (|sig_F === ~|sig_I)\n);", "multi_bit_signals": "sig_F sig_I", "signal_list": "[5:0] sig_F,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-204", "problem": "sig_I not being 1'b1 should be different from the bitwise or of sig_B and sig_E", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_B,\n    input [3:0] sig_E,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I !== 1'b1) != (sig_B | sig_E))\n);", "multi_bit_signals": "sig_I sig_B sig_E", "signal_list": "[3:0] sig_B,[3:0] sig_E,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-205", "problem": "If sig_A and sig_J are both high, then after 5 clock cycles, either sig_F or sig_I will be high", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_F,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_A && sig_J) |-> ##5 (sig_F || sig_I)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_F,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-206", "problem": "The value of (sig_I is not greater than sig_F) must be equal to the logical AND of (the XOR of sig_B and sig_I is not zero) and sig_D", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_D,\n    input [7:0] sig_F,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_I > sig_F) !== 1'b1) === ( ((sig_B ^ sig_I) != 1'b0) && sig_D))\n);", "multi_bit_signals": "sig_I sig_F", "signal_list": "sig_B,sig_D,[7:0] sig_F,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-207", "problem": "If the bitwise AND of sig_I and sig_H have a different value than sig_C, then sig_H is 1", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_C,\n    input [4:0] sig_H,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n     ((sig_I & sig_H) != sig_C) |-> (sig_H == 1'b1)\n);", "multi_bit_signals": "sig_I sig_H sig_C", "signal_list": "[4:0] sig_C,[4:0] sig_H,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-208", "problem": "If the XOR reduction of sig_J equals 1, then either sig_F or the inversion of sig_J must be different from 1 in the next cycle", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_F,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (^sig_J) |=> (sig_F != 1'b1 || (~sig_J) != 1'b1)\n);", "multi_bit_signals": "sig_J sig_F sig_J", "signal_list": "[7:0] sig_F,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-209", "problem": "sig_F must be equal to sig_G", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_F,\n    input [4:0] sig_G\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_F == sig_G\n);", "multi_bit_signals": "sig_F sig_G", "signal_list": "[4:0] sig_F,[4:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-210", "problem": "sig_H is not 1 or sig_C is true, or sig_A is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_C,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_H != 1'b1) || sig_C || sig_A\n);", "multi_bit_signals": "sig_H", "signal_list": "sig_A,sig_C,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-211", "problem": "sig_C or sig_E must be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C || sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_E"}
{"name": "FVEval-NL2SVA-Machine-212", "problem": "If sig_F is true, then the condition that the bitwise AND reduction of sig_I being greater than or equal to sig_G is false", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [3:0] sig_G,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_F |-> ((&sig_I >= sig_G) !== 1'b1)\n);", "multi_bit_signals": "sig_I sig_G", "signal_list": "sig_F,[3:0] sig_G,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-213", "problem": "sig_H must never be high", "testbench": "module testbench (\n    input clk,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H !== 1'b1)\n);", "multi_bit_signals": "", "signal_list": "sig_H"}
{"name": "FVEval-NL2SVA-Machine-215", "problem": "When sig_F is not equal to the logical AND of sig_I and sig_G, both sig_B and sig_I must be true in the subsequent cycle", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F,\n    input sig_G,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F !== (sig_I && sig_G)) |=> (sig_B && sig_I)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_F,sig_G,sig_I"}
{"name": "FVEval-NL2SVA-Machine-216", "problem": "If sig_H changes, then sig_E must be true on the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    $changed(sig_H) |=> sig_E\n);", "multi_bit_signals": "sig_H", "signal_list": "sig_E,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-217", "problem": "If sig_B remains stable, either sig_D or sig_G will be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_G,\n    input [5:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t$stable(sig_B) |=> (sig_D || sig_G)\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_D,sig_G,[5:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-218", "problem": "If sig_D contains at least one '1' bit or sig_H is true, then (the logic AND of sig_D and none of the bits in sig_B are '1') must not be equal to sig_C", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_H,\n    input [3:0] sig_B,\n    input [3:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(|sig_D || sig_H) |-> ((sig_D && ~|sig_B) !== sig_C)\n);", "multi_bit_signals": "sig_D sig_B", "signal_list": "sig_C,sig_H,[3:0] sig_B,[3:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-219", "problem": "If sig_D is not equal to sig_A, then it must eventually be true that sig_G does not contain any '1' bits", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_A,\n    input [7:0] sig_D,\n    input [7:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D !== sig_A) |-> s_eventually((|sig_G !== 1'b1))\n);", "multi_bit_signals": "sig_D sig_A sig_G", "signal_list": "[7:0] sig_A,[7:0] sig_D,[7:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-220", "problem": "Whenever sig_B is not 1, the logical XOR of sig_B and sig_I must equal sig_G", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_B,\n    input [4:0] sig_G,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_B != 5'b1) |-> ((sig_B ^ sig_I) == sig_G)\n);", "multi_bit_signals": "sig_B sig_I sig_G", "signal_list": "[4:0] sig_B,[4:0] sig_G,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-221", "problem": "If sig_G is equal to the value of either sig_F or sig_B being false, then after 5 or 6 clock cycles, both sig_D and sig_F must be true", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_D,\n    input sig_F,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G === (!sig_F || !sig_B)) |-> ##[5:6] (sig_D && sig_F)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_D,sig_F,sig_G"}
{"name": "FVEval-NL2SVA-Machine-222", "problem": "If sig_I is different from sig_D, then after 5 clock cycles, either sig_J will be true or both sig_D and sig_F will be true", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_J,\n    input [6:0] sig_D,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_I != sig_D) |-> ##5 (sig_J || (sig_D && sig_F))\n);", "multi_bit_signals": "sig_I sig_D", "signal_list": "sig_F,sig_J,[6:0] sig_D,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-223", "problem": "sig_B must be greater than sig_I and sig_F must be true", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [4:0] sig_B,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_B > sig_I) && sig_F)\n);", "multi_bit_signals": "sig_B sig_I", "signal_list": "sig_F,[4:0] sig_B,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-224", "problem": "If sig_A is nonzero or the bitwise NOT of sig_C XOR-ed with the bitwise AND reduction of sig_A is true, then sig_H XOR-ed with sig_C must be nonzero in the next cycle", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_A,\n    input [7:0] sig_C,\n    input [7:0] sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A != 1'b0) || (~sig_C ^ &sig_A)) |=> ((sig_H ^ sig_C) != 1'b0)\n);", "multi_bit_signals": "sig_C sig_A sig_H", "signal_list": "[7:0] sig_A,[7:0] sig_C,[7:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-225", "problem": "sig_A bitwise-XOR sig_D must not be equal to (sig_C OR ((reduced XORed of sig_J) AND sig_H))", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_A,\n    input [4:0] sig_C,\n    input [4:0] sig_D,\n    input [4:0] sig_H,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A ^ sig_D) !== (sig_C | (^sig_J & sig_H)))\n);", "multi_bit_signals": "sig_A sig_D sig_C sig_J sig_H", "signal_list": "[4:0] sig_A,[4:0] sig_C,[4:0] sig_D,[4:0] sig_H,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-226 ", "problem": "sig_E not being the bitwise negation of sig_J must not be equal to sig_H XOR the bitwise NAND reduction of sig_E", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_E,\n    input [7:0] sig_H,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_E !== ~sig_J) !== (sig_H ^ ~&sig_E))\n);", "multi_bit_signals": "sig_E sig_J sig_H sig_E", "signal_list": "[7:0] sig_E,[7:0] sig_H,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-227", "problem": "sig_E XORed with sig_I must be equal to (sig_E XOR sig_F) XOR sig_J", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_E,\n    input [7:0] sig_F,\n    input [7:0] sig_I,\n    input [7:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_E ^ sig_I) == ((sig_E ^ sig_F) ^ sig_J) )\n);", "multi_bit_signals": "sig_E sig_I sig_F sig_J", "signal_list": "[7:0] sig_E,[7:0] sig_F,[7:0] sig_I,[7:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-228", "problem": "If sig_D does not contain any '1' bit, then either sig_E or sig_H is true", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_H,\n    input [6:0] sig_D\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (~|sig_D) |-> (sig_E || sig_H)\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_E,sig_H,[6:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-230", "problem": "sig_C is greater than or equal to the bitwise negation of sig_H", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C >= ~sig_H)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_H"}
{"name": "FVEval-NL2SVA-Machine-231", "problem": "If sig_J is true, then sig_I must eventually become true", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> strong(##[0:$] sig_I)\n);", "multi_bit_signals": "", "signal_list": "sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-232", "problem": "If either sig_H, sig_J, or sig_F is true, then after 5 clock cycles, sig_I must be equal to sig_G", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_H,\n    input sig_J,\n    input [6:0] sig_G,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_H || sig_J) || sig_F) |-> ##5 (sig_I === sig_G)\n);", "multi_bit_signals": "sig_I sig_G", "signal_list": "sig_F,sig_H,sig_J,[6:0] sig_G,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-233", "problem": "The exclusive OR of sig_J and sig_A must be less than the exclusive OR of sig_D with the NOR induction of sig_H and then exclusive OR with sig_G", "testbench": "module testbench (\n    input clk,\n    input [4:0] sig_A,\n    input [4:0] sig_D,\n    input [4:0] sig_G,\n    input [4:0] sig_H,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J ^ sig_A) < ((sig_D ^ ~|sig_H) ^ sig_G))\n);", "multi_bit_signals": "sig_J sig_A sig_D sig_H sig_G", "signal_list": "[4:0] sig_A,[4:0] sig_D,[4:0] sig_G,[4:0] sig_H,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-234", "problem": "If sig_G is high, then after five clock cycles, sig_I will be high", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> ##5 sig_I\n);", "multi_bit_signals": "", "signal_list": "sig_G,sig_I"}
{"name": "FVEval-NL2SVA-Machine-235", "problem": "Whenever sig_J has all bits low, and sig_G is high, it is required that (sig_D XOR NOT sig_I) equals 1", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [3:0] sig_D,\n    input [3:0] sig_I,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_J == 4'b0 && sig_G) |-> ((sig_D ^ ~sig_I) == 1'b1)\n);", "multi_bit_signals": "sig_J sig_D sig_I", "signal_list": "sig_G,[3:0] sig_D,[3:0] sig_I,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-236", "problem": "Either sig_C or sig_J is true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C || sig_J)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_J"}
{"name": "FVEval-NL2SVA-Machine-237", "problem": "sig_F is true, and the bitwise XOR of sig_I and sig_D equals the bitwise negation of the AND of sig_J and sig_A", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [5:0] sig_A,\n    input [5:0] sig_D,\n    input [5:0] sig_I,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_F && ((sig_I ^ sig_D) === ~(sig_J & sig_A))\n);", "multi_bit_signals": "sig_I sig_D sig_J sig_A", "signal_list": "sig_F,[5:0] sig_A,[5:0] sig_D,[5:0] sig_I,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-238", "problem": "If sig_A is greater than or equal to sig_B and sig_D is high, eventually sig_E is high", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_E,\n    input [6:0] sig_A,\n    input [6:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A >= sig_B) && sig_D) |-> s_eventually(sig_E)\n);", "multi_bit_signals": "sig_A sig_B", "signal_list": "sig_D,sig_E,[6:0] sig_A,[6:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-239", "problem": "Either sig_D or the bitwise negation of sig_F is different from sig_G, or sig_F has an odd number of bits set to '1' and the number of  '1' is greater than sig_C", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_C,\n    input [6:0] sig_D,\n    input [6:0] sig_F,\n    input [6:0] sig_G\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_D != sig_G) || ((~sig_F) != sig_G) ) ||\n    ( (^sig_F) && ($countones(sig_F) > sig_C) )\n);", "multi_bit_signals": "sig_D sig_F sig_G sig_C", "signal_list": "[6:0] sig_C,[6:0] sig_D,[6:0] sig_F,[6:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-240", "problem": "The OR reduction of sig_J is equal to the inverted OR reduction of sig_G", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_G,\n    input [6:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(|sig_J === ~|sig_G)\n);", "multi_bit_signals": "sig_J sig_G", "signal_list": "[6:0] sig_G,[6:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-241", "problem": "sig_J is the bitwise inverse of sig_C and sig_F is true", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [3:0] sig_C,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J === ~sig_C) && sig_F)\n);", "multi_bit_signals": "sig_J sig_C", "signal_list": "sig_F,[3:0] sig_C,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-242", "problem": "For every rising edge of the clock, sig_H must be high when all bits of sig_B are high", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [3:0] sig_B\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (&sig_B) |-> sig_H\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_H,[3:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-243", "problem": "Either sig_H is true, or sig_G is not equal to 1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [3:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H || (sig_G !== 1'b1))\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_H,[3:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-244", "problem": "sig_C or sig_I must be true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C || sig_I)\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_I"}
{"name": "FVEval-NL2SVA-Machine-245", "problem": "If either sig_I or sig_D is true, then sig_A and sig_G must always be different", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_I,\n    input [5:0] sig_A,\n    input [5:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_I || sig_D) |-> always((sig_A ^ sig_G))\n);", "multi_bit_signals": "sig_A sig_G", "signal_list": "sig_D,sig_I,[5:0] sig_A,[5:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-246", "problem": "sig_C must be high and sig_F must be greater than sig_A", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [3:0] sig_A,\n    input [3:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_C && (sig_F > sig_A))\n);", "multi_bit_signals": "sig_F sig_A", "signal_list": "sig_C,[3:0] sig_A,[3:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-247", "problem": "If sig_B or sig_H is high, then after 4 to 6 clock cycles, sig_F and sig_D will have opposite values", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_D,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B || sig_H) |-> ##[4:6] (sig_F ^ sig_D)\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_D,sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-248", "problem": "sig_E and sig_G are both high", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_E && sig_G)\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_G"}
{"name": "FVEval-NL2SVA-Machine-249", "problem": "If any bit in sig_I is high, then sig_J will be true in the next clock cycle", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t|sig_I |=> sig_J\n);", "multi_bit_signals": "sig_I", "signal_list": "sig_J,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-250", "problem": "If sig_D is high and all bits of sig_G are high, then sig_J will be high 4 clock cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_J,\n    input [7:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_D && (&sig_G)) |-> ##4 sig_J\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_D,sig_J,[7:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-251", "problem": "If sig_I is true, then sig_J must be true and sig_H must be equal to sig_J", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_I |-> (sig_J && (sig_H == sig_J))\n);", "multi_bit_signals": "", "signal_list": "sig_H,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-253", "problem": "If sig_G is true, then sig_J must be true after exactly 4 clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> ##4 sig_J\n);", "multi_bit_signals": "", "signal_list": "sig_G,sig_J"}
{"name": "FVEval-NL2SVA-Machine-255", "problem": "If (sig_A is equal to sig_E) and (sig_D is high), then after 5 clock cycles, sig_C will be high", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_D,\n    input [6:0] sig_A,\n    input [6:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A === sig_E) && sig_D) |-> ##5 sig_C\n);", "multi_bit_signals": "sig_A sig_E", "signal_list": "sig_C,sig_D,[6:0] sig_A,[6:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-256", "problem": "sig_B is equal to 1 and sig_C is true", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [4:0] sig_B\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B == 1'b1) && sig_C\n);", "multi_bit_signals": "sig_B", "signal_list": "sig_C,[4:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-257", "problem": "sig_H is true and sig_G is not equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input [5:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H && (sig_G !== 1'b1))\n);", "multi_bit_signals": "sig_G", "signal_list": "sig_H,[5:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-258", "problem": "If either sig_J or sig_A is true, then sig_I must have been true two cycles ago", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J || sig_A) |-> $past(sig_I, 2)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-259", "problem": "When sig_H becomes true, both sig_F and sig_E must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_E,\n    input sig_F,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_H |=> (sig_F && sig_E)\n);", "multi_bit_signals": "", "signal_list": "sig_E,sig_F,sig_H"}
{"name": "FVEval-NL2SVA-Machine-260", "problem": "The bitwise XOR of sig_C and sig_F is less than or equal to the reduction XOR of sig_J", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_C,\n    input [3:0] sig_F,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_C ^ sig_F) <= ^sig_J)\n);", "multi_bit_signals": "sig_C sig_F sig_J", "signal_list": "[3:0] sig_C,[3:0] sig_F,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-261", "problem": "sig_A and sig_J together should never both be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A && sig_J) !== 1'b1)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_J"}
{"name": "FVEval-NL2SVA-Machine-262", "problem": "Either sig_B is high or both sig_G and sig_H are high", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_G,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_B || (sig_G && sig_H))\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_G,sig_H"}
{"name": "FVEval-NL2SVA-Machine-263", "problem": "Either sig_I must be true, or sig_H must be true, or sig_A must be true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_H,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_I || (sig_H || sig_A))\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_H,sig_I"}
{"name": "FVEval-NL2SVA-Machine-264", "problem": "If sig_G is not equal to sig_D and sig_G is not equal to the bitwise XNOR reduction of sig_B, then sig_C must not be all 1's", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_B,\n    input [3:0] sig_C,\n    input [3:0] sig_D,\n    input [3:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_G !== sig_D) && (sig_G !== ~^sig_B)) |-> (&sig_C !== 1'b1)\n);", "multi_bit_signals": "sig_G sig_D sig_B sig_C", "signal_list": "[3:0] sig_B,[3:0] sig_C,[3:0] sig_D,[3:0] sig_G"}
{"name": "FVEval-NL2SVA-Machine-265", "problem": "If sig_B is not equal to 1, then sig_G must be low or sig_A must be equal to sig_B", "testbench": "module testbench (\n    input clk,\n    input sig_G,\n    input [7:0] sig_A,\n    input [7:0] sig_B\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_B != 1'b1) |-> (!sig_G || (sig_A == sig_B))\n);", "multi_bit_signals": "sig_B sig_A", "signal_list": "sig_G,[7:0] sig_A,[7:0] sig_B"}
{"name": "FVEval-NL2SVA-Machine-266", "problem": "If sig_F is high, then sig_B will be true after two clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_F |-> ##2 sig_B\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_F"}
{"name": "FVEval-NL2SVA-Machine-267", "problem": "The combination of ((sig_J bitwise-OR sig_B) bitwise-AND sig_A) must not be equal to (sig_G being greater than or equal to sig_A)", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_G,\n    input [3:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_J | sig_B) & sig_A) !== (sig_G >= sig_A)\n);", "multi_bit_signals": "sig_J sig_B sig_A sig_G", "signal_list": "[3:0] sig_A,[3:0] sig_B,[3:0] sig_G,[3:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-268", "problem": "If sig_J is true, then within 1 to 4 clock cycles, sig_I must be equal to sig_G", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [4:0] sig_G,\n    input [4:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> ##[1:4] (sig_I === sig_G)\n);", "multi_bit_signals": "sig_I sig_G", "signal_list": "sig_J,[4:0] sig_G,[4:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-270", "problem": "If sig_H is not equal to sig_D, then sig_J must have an odd number of '1' bits or sig_I must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input [4:0] sig_D,\n    input [4:0] sig_H,\n    input [4:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H !== sig_D) |=> (^sig_J || sig_I)\n);", "multi_bit_signals": "sig_H sig_D sig_J", "signal_list": "sig_I,[4:0] sig_D,[4:0] sig_H,[4:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-271", "problem": "sig_F and sig_I cannot both be high", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_F && sig_I) !== 1'b1)\n);", "multi_bit_signals": "", "signal_list": "sig_F,sig_I"}
{"name": "FVEval-NL2SVA-Machine-272", "problem": "sig_I is less or equal to sig_D, or sig_A is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input [6:0] sig_D,\n    input [6:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_I <= sig_D) || sig_A)\n);", "multi_bit_signals": "sig_I sig_D", "signal_list": "sig_A,[6:0] sig_D,[6:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-273", "problem": "If sig_J is true, then (the value of sig_D and sig_B being both true or both false) is equivalent to sig_E not being equal to sig_C", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input sig_D,\n    input sig_E,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> ((sig_D == sig_B) === (sig_E !== sig_C))\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_C,sig_D,sig_E,sig_J"}
{"name": "FVEval-NL2SVA-Machine-274", "problem": "The value of sig_J must be the inverse of whether sig_E is less than sig_B", "testbench": "module testbench (\n    input clk,\n    input sig_J,\n    input [4:0] sig_B,\n    input [4:0] sig_E\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    sig_J == !(sig_E < sig_B)\n);", "multi_bit_signals": "sig_E sig_B", "signal_list": "sig_J,[4:0] sig_B,[4:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-275", "problem": "If sig_D is 1, sig_F must not be 1 ", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_D,\n    input [6:0] sig_F\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (sig_D == 1'b1) |-> (sig_F != 1'b1)\n);", "multi_bit_signals": "sig_D sig_F", "signal_list": "[6:0] sig_D,[6:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-276", "problem": "sig_E is not equal to 1, or sig_D must be equal to sig_F", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_D,\n    input [3:0] sig_E,\n    input [3:0] sig_F\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_E !== 1'b1) || (sig_D === sig_F))\n);", "multi_bit_signals": "sig_E sig_D sig_F", "signal_list": "[3:0] sig_D,[3:0] sig_E,[3:0] sig_F"}
{"name": "FVEval-NL2SVA-Machine-277", "problem": "If sig_J is true, then sig_B must be true after three clock cycles", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |-> ##3 sig_B\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_J"}
{"name": "FVEval-NL2SVA-Machine-278", "problem": "If sig_F is less than the bitwise negation of sig_I, then sig_J must be different from sig_H in the next cycle", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_F,\n    input [6:0] sig_H,\n    input [6:0] sig_I,\n    input [6:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F < (~sig_I)) |=> (sig_J ^ sig_H)\n);", "multi_bit_signals": "sig_F sig_I sig_J sig_H", "signal_list": "[6:0] sig_F,[6:0] sig_H,[6:0] sig_I,[6:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-279", "problem": "sig_J and sig_E are not both true, and sig_A or sig_J is true", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_E,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (!(sig_J && sig_E) && (sig_A || sig_J))\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_E,sig_J"}
{"name": "FVEval-NL2SVA-Machine-280", "problem": "If sig_A is not high, then either sig_G should not be high or sig_I must be true after one cycle", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_G,\n    input sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    !sig_A |=> (!sig_G || sig_I)\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_G,sig_I"}
{"name": "FVEval-NL2SVA-Machine-281", "problem": "If sig_J XORed with the complement of the AND reduction of sig_A is true, then sig_H must eventually be true", "testbench": "module testbench (\n    input clk,\n    input sig_H,\n    input sig_J,\n    input [5:0] sig_A\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J ^ ~&sig_A) |-> s_eventually(sig_H)\n);", "multi_bit_signals": "sig_A", "signal_list": "sig_H,sig_J,[5:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-282", "problem": "sig_G is high or sig_A is equal to the logical OR of sig_I and sig_J", "testbench": "module testbench (\n    input clk,\n    input sig_A,\n    input sig_G,\n    input sig_I,\n    input sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_G || (sig_A === (sig_I || sig_J)))\n);", "multi_bit_signals": "", "signal_list": "sig_A,sig_G,sig_I,sig_J"}
{"name": "FVEval-NL2SVA-Machine-283", "problem": "The value of sig_I XOR sig_D must be equal to the inequality comparison between (sig_G XOR sig_A) and sig_F", "testbench": "module testbench (\n    input clk,\n    input [5:0] sig_A,\n    input [5:0] sig_D,\n    input [5:0] sig_F,\n    input [5:0] sig_G,\n    input [5:0] sig_I\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ( (sig_I ^ sig_D) == ( (sig_G ^ sig_A) != sig_F ) )\n);", "multi_bit_signals": "sig_I sig_D sig_G sig_A sig_F", "signal_list": "[5:0] sig_A,[5:0] sig_D,[5:0] sig_F,[5:0] sig_G,[5:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-284", "problem": "If (the bitwise AND of sig_A and sig_J) is less than (the bitwise OR of sig_C and sig_A), then within 4 to 9 cycles, sig_C and sig_E must be different", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_A,\n    input [6:0] sig_C,\n    input [6:0] sig_E,\n    input [6:0] sig_J\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_A & sig_J) < (sig_C | sig_A)) |-> ##[4:9] (sig_C ^ sig_E)\n);", "multi_bit_signals": "sig_A sig_J sig_C sig_E", "signal_list": "[6:0] sig_A,[6:0] sig_C,[6:0] sig_E,[6:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-285", "problem": "sig_F must be true if and only if sig_H is true or all bits of sig_E are true", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_H,\n    input [7:0] sig_E\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_F === (sig_H || &sig_E))\n);", "multi_bit_signals": "sig_E", "signal_list": "sig_F,sig_H,[7:0] sig_E"}
{"name": "FVEval-NL2SVA-Machine-287", "problem": "The bitwise negation of sig_A should not be equal to 1", "testbench": "module testbench (\n    input clk,\n    input [6:0] sig_A\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(~sig_A !== 1'b1)\n);", "multi_bit_signals": "sig_A", "signal_list": "[6:0] sig_A"}
{"name": "FVEval-NL2SVA-Machine-288", "problem": "Both sig_D and sig_C are high implies that both sig_D and sig_B are high,", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_C,\n    input sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_D && sig_C) |-> (sig_D && sig_B))\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_C,sig_D"}
{"name": "FVEval-NL2SVA-Machine-289", "problem": "If sig_D is high, then sig_C must be true in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_D |=> sig_C\n);", "multi_bit_signals": "", "signal_list": "sig_C,sig_D"}
{"name": "FVEval-NL2SVA-Machine-290", "problem": "If sig_B is high, then sig_H must become high between 3 and 7 cycles later", "testbench": "module testbench (\n    input clk,\n    input sig_B,\n    input sig_H\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_B |-> ##[3:7] sig_H\n);", "multi_bit_signals": "", "signal_list": "sig_B,sig_H"}
{"name": "FVEval-NL2SVA-Machine-291", "problem": "If sig_J is high and sig_F differs from the OR reduction of sig_C, then sig_B not being equal to 1'b1 must differ from sig_G", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input sig_G,\n    input sig_J,\n    input [4:0] sig_B,\n    input [4:0] sig_C\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_J && (sig_F != (|sig_C))) |-> ((sig_B !== 1'b1) != sig_G)\n);", "multi_bit_signals": "sig_C sig_B", "signal_list": "sig_F,sig_G,sig_J,[4:0] sig_B,[4:0] sig_C"}
{"name": "FVEval-NL2SVA-Machine-292", "problem": "The bitwise negation of the logical AND of all bits in sig_F should not be equal to the XOR of sig_A and sig_H", "testbench": "module testbench (\n    input clk,\n    input [3:0] sig_A,\n    input [3:0] sig_F,\n    input [3:0] sig_H\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    (~&sig_F) != (sig_A ^ sig_H)\n);", "multi_bit_signals": "sig_F sig_A sig_H", "signal_list": "[3:0] sig_A,[3:0] sig_F,[3:0] sig_H"}
{"name": "FVEval-NL2SVA-Machine-293", "problem": "If sig_J is true, then either sig_I must be true or all bits in sig_D must be low at the next clock edge", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input sig_J,\n    input [7:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_J |=> (sig_I || ~|sig_D)\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_I,sig_J,[7:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-294", "problem": "If either sig_H or sig_I is high, or sig_E differs from the negated value of sig_I, then sig_D will transition from low to high in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input sig_H,\n    input [7:0] sig_E,\n    input [7:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t((sig_H || sig_I) || (sig_E != !sig_I)) |=> $rose(sig_D)\n);", "multi_bit_signals": "sig_E sig_I", "signal_list": "sig_D,sig_H,[7:0] sig_E,[7:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-295", "problem": "If sig_H and sig_I are different values, then sig_D holds in the next cycle", "testbench": "module testbench (\n    input clk,\n    input sig_D,\n    input [3:0] sig_H,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(sig_H ^ sig_I) |=> sig_D\n);", "multi_bit_signals": "sig_H sig_I", "signal_list": "sig_D,[3:0] sig_H,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-296", "problem": "When sig_J is less than sig_F and sig_I is true, the value of the bitwise negated XOR reduction of sig_C is also true", "testbench": "module testbench (\n    input clk,\n    input sig_I,\n    input [5:0] sig_C,\n    input [5:0] sig_F,\n    input [5:0] sig_J\n);\nendmodule", "ground_truth": "assert property (@(posedge clk)\n    ((sig_J < sig_F) && sig_I) |-> (~^sig_C)\n);", "multi_bit_signals": "sig_J sig_F sig_C", "signal_list": "sig_I,[5:0] sig_C,[5:0] sig_F,[5:0] sig_J"}
{"name": "FVEval-NL2SVA-Machine-297", "problem": "sig_G is less than sig_A or sig_I is less than or equal to sig_G, and sig_B contains at least one '1' bit and sig_C is high", "testbench": "module testbench (\n    input clk,\n    input sig_C,\n    input [3:0] sig_A,\n    input [3:0] sig_B,\n    input [3:0] sig_G,\n    input [3:0] sig_I\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\t(((sig_G < sig_A) || (sig_I <= sig_G)) && (|sig_B && sig_C))\n);", "multi_bit_signals": "sig_G sig_A sig_I sig_B", "signal_list": "sig_C,[3:0] sig_A,[3:0] sig_B,[3:0] sig_G,[3:0] sig_I"}
{"name": "FVEval-NL2SVA-Machine-298", "problem": "If sig_F is true, then five cycles later sig_D must not be equal to 1'b1", "testbench": "module testbench (\n    input clk,\n    input sig_F,\n    input [3:0] sig_D\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_F |-> ##5 (sig_D !== 1'b1)\n);", "multi_bit_signals": "sig_D", "signal_list": "sig_F,[3:0] sig_D"}
{"name": "FVEval-NL2SVA-Machine-299", "problem": "If sig_G is true, then after three clock cycles, sig_B must be different from sig_G", "testbench": "module testbench (\n    input clk,\n    input [7:0] sig_B,\n    input [7:0] sig_G\n);\nendmodule", "ground_truth": "assert property(@(posedge clk)\n\tsig_G |-> ##3 (sig_B ^ sig_G)\n);", "multi_bit_signals": "sig_B sig_G", "signal_list": "[7:0] sig_B,[7:0] sig_G"}
