{"name": "FVEval-NL2SVA-Human-0", "problem": "that if the current cycle is neither a jump operation nor immediately after a reset pulse, the counter must not overflow. Use the signals 'count', 'jump_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.", "testbench": "module counter_tb (\nclk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value\n);\n\n    parameter width = 1;\n    parameter min = 0;\n    parameter [width:0] max = ((1<<width)-1);\n\ninput clk;\ninput reset_;\ninput [width-1:0] count;\ninput             incr_vld;\ninput [width-1:0] incr_value;\ninput             decr_vld;\ninput [width-1:0] decr_value;\ninput             jump_vld;\ninput [width-1:0] jump_value;\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;\nwire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;\nwire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};\nwire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};\n\n\nreg [width-1:0] eff_incr_d1;\nreg [width-1:0] eff_decr_d1;\nreg [width-1:0] net_incr_d1;\nreg [width-1:0] net_decr_d1;\n\nreg [width-1:0] count_d1;\nreg             incr_vld_d1;\nreg [width-1:0] incr_value_d1;\nreg             decr_vld_d1;\nreg [width-1:0] decr_value_d1;\nreg             jump_vld_d1;\nreg [width-1:0] jump_value_d1;\n\nreg [width:0]     count_d1_next;\nreg [width:0]     count_d1_next_p;\nreg [width:0]     count_d1_next_m;\n\nreg tb_reset_d1;\nreg tb_reset_d2;\nreg tb_reset_1_cycle_pulse_shadow;\n\nalways @(posedge clk) begin\n    if (!reset_) begin \n        incr_vld_d1 <= 1'b0;\n        decr_vld_d1 <= 1'b0;\n        jump_vld_d1 <= 1'b0;\n        eff_incr_d1 <= {width{1'b0}};\n        eff_decr_d1 <= {width{1'b0}};\n        net_incr_d1 <= {width{1'b0}};\n        net_decr_d1 <= {width{1'b0}};\n    end else begin\n        eff_incr_d1 <= eff_incr;\n        eff_decr_d1 <= eff_decr;\n        net_incr_d1 <= net_incr;\n        net_decr_d1 <= net_decr;\n        incr_vld_d1 <= incr_vld;\n        decr_vld_d1 <= decr_vld;\n        jump_vld_d1 <= jump_vld;         \n    end\nend\n\nalways @(posedge clk) begin\n        count_d1 <= count;\n        incr_value_d1 <= incr_value;\n        decr_value_d1 <= decr_value;\n        jump_value_d1 <= jump_value;\n        tb_reset_d1 <= tb_reset;          \n        tb_reset_d2 <= tb_reset_d1;         \nend\nalways @(posedge clk) begin\n    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;\n    count_d1_next_m <= count_d1 - net_decr_d1;\n    count_d1_next_p <= count_d1 + net_incr_d1;\n    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!jump_vld_d1 && !tb_reset_1_cycle_pulse_shadow) |-> (count <= max)\n);", "signals_for_validity": ["tb_reset_1_cycle_pulse_shadow", "jump_vld_d1", "count"]}
{"name": "FVEval-NL2SVA-Human-1", "problem": "that if the current cycle is neither a jump operation nor immediately after a reset pulse, the counter must not underflow. Use the signals 'count', 'jump_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.", "testbench": "module counter_tb (\nclk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value\n);\n\n    parameter width = 1;\n    parameter min = 0;\n    parameter [width:0] max = ((1<<width)-1);\n\ninput clk;\ninput reset_;\ninput [width-1:0] count;\ninput             incr_vld;\ninput [width-1:0] incr_value;\ninput             decr_vld;\ninput [width-1:0] decr_value;\ninput             jump_vld;\ninput [width-1:0] jump_value;\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;\nwire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;\nwire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};\nwire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};\n\n\nreg [width-1:0] eff_incr_d1;\nreg [width-1:0] eff_decr_d1;\nreg [width-1:0] net_incr_d1;\nreg [width-1:0] net_decr_d1;\n\nreg [width-1:0] count_d1;\nreg             incr_vld_d1;\nreg [width-1:0] incr_value_d1;\nreg             decr_vld_d1;\nreg [width-1:0] decr_value_d1;\nreg             jump_vld_d1;\nreg [width-1:0] jump_value_d1;\n\nreg [width:0]     count_d1_next;\nreg [width:0]     count_d1_next_p;\nreg [width:0]     count_d1_next_m;\n\nreg tb_reset_d1;\nreg tb_reset_d2;\nreg tb_reset_1_cycle_pulse_shadow;\n\nalways @(posedge clk) begin\n    if (!reset_) begin \n        incr_vld_d1 <= 1'b0;\n        decr_vld_d1 <= 1'b0;\n        jump_vld_d1 <= 1'b0;\n        eff_incr_d1 <= {width{1'b0}};\n        eff_decr_d1 <= {width{1'b0}};\n        net_incr_d1 <= {width{1'b0}};\n        net_decr_d1 <= {width{1'b0}};\n    end else begin\n        eff_incr_d1 <= eff_incr;\n        eff_decr_d1 <= eff_decr;\n        net_incr_d1 <= net_incr;\n        net_decr_d1 <= net_decr;\n        incr_vld_d1 <= incr_vld;\n        decr_vld_d1 <= decr_vld;\n        jump_vld_d1 <= jump_vld;         \n    end\nend\n\nalways @(posedge clk) begin\n        count_d1 <= count;\n        incr_value_d1 <= incr_value;\n        decr_value_d1 <= decr_value;\n        jump_value_d1 <= jump_value;\n        tb_reset_d1 <= tb_reset;          \n        tb_reset_d2 <= tb_reset_d1;         \nend\nalways @(posedge clk) begin\n    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;\n    count_d1_next_m <= count_d1 - net_decr_d1;\n    count_d1_next_p <= count_d1 + net_incr_d1;\n    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!jump_vld_d1 && !tb_reset_1_cycle_pulse_shadow) |-> (count >= min)\n);", "signals_for_validity": ["tb_reset_1_cycle_pulse_shadow", "jump_vld_d1", "count"]}
{"name": "FVEval-NL2SVA-Human-2", "problem": "that the counter count value is within legal range. Use the signal 'count'.", "testbench": "module counter_tb (\nclk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value\n);\n\n    parameter width = 1;\n    parameter min = 0;\n    parameter [width:0] max = ((1<<width)-1);\n\ninput clk;\ninput reset_;\ninput [width-1:0] count;\ninput             incr_vld;\ninput [width-1:0] incr_value;\ninput             decr_vld;\ninput [width-1:0] decr_value;\ninput             jump_vld;\ninput [width-1:0] jump_value;\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;\nwire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;\nwire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};\nwire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};\n\n\nreg [width-1:0] eff_incr_d1;\nreg [width-1:0] eff_decr_d1;\nreg [width-1:0] net_incr_d1;\nreg [width-1:0] net_decr_d1;\n\nreg [width-1:0] count_d1;\nreg             incr_vld_d1;\nreg [width-1:0] incr_value_d1;\nreg             decr_vld_d1;\nreg [width-1:0] decr_value_d1;\nreg             jump_vld_d1;\nreg [width-1:0] jump_value_d1;\n\nreg [width:0]     count_d1_next;\nreg [width:0]     count_d1_next_p;\nreg [width:0]     count_d1_next_m;\n\nreg tb_reset_d1;\nreg tb_reset_d2;\nreg tb_reset_1_cycle_pulse_shadow;\n\nalways @(posedge clk) begin\n    if (!reset_) begin \n        incr_vld_d1 <= 1'b0;\n        decr_vld_d1 <= 1'b0;\n        jump_vld_d1 <= 1'b0;\n        eff_incr_d1 <= {width{1'b0}};\n        eff_decr_d1 <= {width{1'b0}};\n        net_incr_d1 <= {width{1'b0}};\n        net_decr_d1 <= {width{1'b0}};\n    end else begin\n        eff_incr_d1 <= eff_incr;\n        eff_decr_d1 <= eff_decr;\n        net_incr_d1 <= net_incr;\n        net_decr_d1 <= net_decr;\n        incr_vld_d1 <= incr_vld;\n        decr_vld_d1 <= decr_vld;\n        jump_vld_d1 <= jump_vld;         \n    end\nend\n\nalways @(posedge clk) begin\n        count_d1 <= count;\n        incr_value_d1 <= incr_value;\n        decr_value_d1 <= decr_value;\n        jump_value_d1 <= jump_value;\n        tb_reset_d1 <= tb_reset;          \n        tb_reset_d2 <= tb_reset_d1;         \nend\nalways @(posedge clk) begin\n    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;\n    count_d1_next_m <= count_d1 - net_decr_d1;\n    count_d1_next_p <= count_d1 + net_incr_d1;\n    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    ((count < min) || (count > max)) !== 1'b1\n);", "signals_for_validity": ["count"]}
{"name": "FVEval-NL2SVA-Human-3", "problem": "that for the jump case, counter is properly assigned with the jump value. Use the signals 'count', 'jump_vld_d1' and 'jump_value_d1'.", "testbench": "module counter_tb (\nclk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value\n);\n\n    parameter width = 1;\n    parameter min = 0;\n    parameter [width:0] max = ((1<<width)-1);\n\ninput clk;\ninput reset_;\ninput [width-1:0] count;\ninput             incr_vld;\ninput [width-1:0] incr_value;\ninput             decr_vld;\ninput [width-1:0] decr_value;\ninput             jump_vld;\ninput [width-1:0] jump_value;\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;\nwire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;\nwire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};\nwire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};\n\n\nreg [width-1:0] eff_incr_d1;\nreg [width-1:0] eff_decr_d1;\nreg [width-1:0] net_incr_d1;\nreg [width-1:0] net_decr_d1;\n\nreg [width-1:0] count_d1;\nreg             incr_vld_d1;\nreg [width-1:0] incr_value_d1;\nreg             decr_vld_d1;\nreg [width-1:0] decr_value_d1;\nreg             jump_vld_d1;\nreg [width-1:0] jump_value_d1;\n\nreg [width:0]     count_d1_next;\nreg [width:0]     count_d1_next_p;\nreg [width:0]     count_d1_next_m;\n\nreg tb_reset_d1;\nreg tb_reset_d2;\nreg tb_reset_1_cycle_pulse_shadow;\n\nalways @(posedge clk) begin\n    if (!reset_) begin \n        incr_vld_d1 <= 1'b0;\n        decr_vld_d1 <= 1'b0;\n        jump_vld_d1 <= 1'b0;\n        eff_incr_d1 <= {width{1'b0}};\n        eff_decr_d1 <= {width{1'b0}};\n        net_incr_d1 <= {width{1'b0}};\n        net_decr_d1 <= {width{1'b0}};\n    end else begin\n        eff_incr_d1 <= eff_incr;\n        eff_decr_d1 <= eff_decr;\n        net_incr_d1 <= net_incr;\n        net_decr_d1 <= net_decr;\n        incr_vld_d1 <= incr_vld;\n        decr_vld_d1 <= decr_vld;\n        jump_vld_d1 <= jump_vld;         \n    end\nend\n\nalways @(posedge clk) begin\n        count_d1 <= count;\n        incr_value_d1 <= incr_value;\n        decr_value_d1 <= decr_value;\n        jump_value_d1 <= jump_value;\n        tb_reset_d1 <= tb_reset;          \n        tb_reset_d2 <= tb_reset_d1;         \nend\nalways @(posedge clk) begin\n    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;\n    count_d1_next_m <= count_d1 - net_decr_d1;\n    count_d1_next_p <= count_d1 + net_incr_d1;\n    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (jump_vld_d1 && (count !== jump_value_d1)) !== 1'b1\n);", "signals_for_validity": ["jump_value_d1", "jump_vld_d1", "count"]}
{"name": "FVEval-NL2SVA-Human-4", "problem": "that if there is no increment, decrement or jump, the counter should retain its value. Use the signals 'count', 'count_d1', 'jump_vld_d1', 'incr_vld_d1', 'decr_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.", "testbench": "module counter_tb (\nclk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value\n);\n\n    parameter width = 1;\n    parameter min = 0;\n    parameter [width:0] max = ((1<<width)-1);\n\ninput clk;\ninput reset_;\ninput [width-1:0] count;\ninput             incr_vld;\ninput [width-1:0] incr_value;\ninput             decr_vld;\ninput [width-1:0] decr_value;\ninput             jump_vld;\ninput [width-1:0] jump_value;\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;\nwire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;\nwire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};\nwire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};\n\n\nreg [width-1:0] eff_incr_d1;\nreg [width-1:0] eff_decr_d1;\nreg [width-1:0] net_incr_d1;\nreg [width-1:0] net_decr_d1;\n\nreg [width-1:0] count_d1;\nreg             incr_vld_d1;\nreg [width-1:0] incr_value_d1;\nreg             decr_vld_d1;\nreg [width-1:0] decr_value_d1;\nreg             jump_vld_d1;\nreg [width-1:0] jump_value_d1;\n\nreg [width:0]     count_d1_next;\nreg [width:0]     count_d1_next_p;\nreg [width:0]     count_d1_next_m;\n\nreg tb_reset_d1;\nreg tb_reset_d2;\nreg tb_reset_1_cycle_pulse_shadow;\n\nalways @(posedge clk) begin\n    if (!reset_) begin \n        incr_vld_d1 <= 1'b0;\n        decr_vld_d1 <= 1'b0;\n        jump_vld_d1 <= 1'b0;\n        eff_incr_d1 <= {width{1'b0}};\n        eff_decr_d1 <= {width{1'b0}};\n        net_incr_d1 <= {width{1'b0}};\n        net_decr_d1 <= {width{1'b0}};\n    end else begin\n        eff_incr_d1 <= eff_incr;\n        eff_decr_d1 <= eff_decr;\n        net_incr_d1 <= net_incr;\n        net_decr_d1 <= net_decr;\n        incr_vld_d1 <= incr_vld;\n        decr_vld_d1 <= decr_vld;\n        jump_vld_d1 <= jump_vld;         \n    end\nend\n\nalways @(posedge clk) begin\n        count_d1 <= count;\n        incr_value_d1 <= incr_value;\n        decr_value_d1 <= decr_value;\n        jump_value_d1 <= jump_value;\n        tb_reset_d1 <= tb_reset;          \n        tb_reset_d2 <= tb_reset_d1;         \nend\nalways @(posedge clk) begin\n    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;\n    count_d1_next_m <= count_d1 - net_decr_d1;\n    count_d1_next_p <= count_d1 + net_incr_d1;\n    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;//High when the counter is reset.\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!incr_vld_d1 && !decr_vld_d1 && !jump_vld_d1 && (count !== count_d1) && !tb_reset_1_cycle_pulse_shadow) !== 1'b1\n);", "signals_for_validity": ["count", "tb_reset_1_cycle_pulse_shadow", "incr_vld_d1", "count_d1", "decr_vld_d1", "jump_vld_d1"]}
{"name": "FVEval-NL2SVA-Human-5", "problem": "that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !($onehot0(tb_gnt)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-6", "problem": "that if there is a req, there is a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-7", "problem": "that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_gnt & ~tb_req) == 0\n);", "signals_for_validity": ["[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-8", "problem": "that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt' and 'busy'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_gnt && busy) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-9", "problem": "that the arbiter holds onto grants when there is hold and the arbiter is not busy. Use the signals 'last_gnt', 'busy', 'tb_gnt' and 'hold'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 \n);", "signals_for_validity": ["[5:0] tb_gnt", "[5:0] last_gnt", "busy", "hold"]}
{"name": "FVEval-NL2SVA-Human-10", "problem": "that the given arbiter follows the priority policy: always grant the highest priority client that is currently requesting. Use the signals 'tb_gnt', 'hold', and 'tb_req'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_gnt && !hold && |((tb_gnt - 'd1) & tb_req)) !== 1'b1\n);", "signals_for_validity": ["hold", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-11", "problem": "that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'busy', 'hold', and 'cont_gnt'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !$onehot0({hold,busy,cont_gnt}) !== 1'b1\n);", "signals_for_validity": ["hold", "busy", "cont_gnt"]}
{"name": "FVEval-NL2SVA-Human-13", "problem": "that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.", "testbench": "module arbiter_reverse_priority_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width:0] gnt_id; // Binary encoded ID of the granted client. 0 indicates no grant. Client numbering starts from 1.\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\n\ngenvar a;\nfor(a=0;a<NUM_OF_CLIENTS;a++) begin \n    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];\n    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];\n    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];\nend\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1\n);", "signals_for_validity": ["[2:0] gnt_id", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-14", "problem": "that each of the FSM states provided as the input sequence should end in the final end state. Use the signal 'match_tracker'.", "testbench": "module fsm_transition_tb (\nclk, \nreset_, \nfsm_state,\nfsm_sequence\n);\n    parameter fsm_width = 2; //actual width of the states in the RTL\n    parameter num_of_states=2; //number of states provided in the fsm_sequence\n    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the \"fsm_sequence\" is repeated in the \"fsm_sequence\"  \n\ninput clk;\ninput reset_;\ninput [fsm_width-1:0]fsm_state;\ninput [fsm_width*num_of_states-1:0]fsm_sequence;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n//Proper sequencing of the states\nwire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; \n\n//match the current \"fsm_state\" with the states provided in the \"fsm_sequence\"\nwire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; \nreg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; \n\n//match the current \"fsm_state\" with the states provided in the \"fsm_sequence\" when checking for individual states\nwire [num_of_states-1:0]ind_state_match_tracker[num_of_times_initial_state_repeats-1:0]; \nreg [num_of_states-1:0]ind_state_match_tracker_d1[num_of_times_initial_state_repeats-1:0]; \n\n//Track all the states of the \"fsm_sequence\"\nreg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; \n\nreg [fsm_width-1:0] fsm_state_d1;\nreg tb_reset_d1;\nwire [fsm_width-1:0] tb_random_state;\nwire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;\n\n\n//storing the states of the fsm_sequence in the correct order\nfor (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states\n    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];\nend\n\n//Delayed versions of fsm_state and tb_reset\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fsm_state_d1 <= 'd0;\n        tb_reset_d1 <= 1;\n    end else begin\n        fsm_state_d1 <= fsm_state;\n        tb_reset_d1 <= tb_reset;  \n    end\nend\n\nfor (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat\n    if (n==0) begin : matching_of_states_for_certain_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n                assign ind_state_match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);\n            end else begin : matching_of_states_for_other_states \n                assign ind_state_match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);\n            end\n        end \n    end else begin : matching_of_states_for_other_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n            assign ind_state_match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) \n                                            : ind_state_match_tracker[n][0] ;\n            end else begin : matching_of_states_for_other_states\n            assign ind_state_match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) \n                                            : ind_state_match_tracker[n][i] ;\n            end\n        end \n    end\nend\n\nreg [$clog2(num_of_times_initial_state_repeats):0] j;\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            state_tracker[j] <= 'd0;\n            match_tracker_d1[j] <= 'd0;\n            ind_state_match_tracker_d1[j] <= 'd0;\n        end\n    end else begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            match_tracker_d1[j] <= match_tracker[j];\n            ind_state_match_tracker_d1[j] <= ind_state_match_tracker[j];\n            if (j==0) \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                        ? state_tracker[j]|match_tracker[j] \n                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) \n                                            ? 'd1 \n                                            : 'd0\n                                        );\n            else \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                    ? state_tracker[j]|match_tracker[j] \n                                    : 'd0;\n        end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !(|(match_tracker[0])) !== 1'b1     \n);", "signals_for_validity": ["[1:0] match_tracker"]}
{"name": "FVEval-NL2SVA-Human-15", "problem": "that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_1r1w_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\n// ---- shift register code start ----\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\n// ---- read pointer/fifo empty code start ----\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\n// ---- fifo full and dout code start ----\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_empty && rd_pop) !== 1'b1\n);", "signals_for_validity": ["rd_pop", "fifo_empty"]}
{"name": "FVEval-NL2SVA-Human-16", "problem": "that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.", "testbench": "module fifo_1r1w_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\n// ---- shift register code start ----\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\n// ---- read pointer/fifo empty code start ----\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\n// ---- fifo full and dout code start ----\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_full && wr_push) !== 1'b1\n);", "signals_for_validity": ["wr_push", "fifo_full"]}
{"name": "FVEval-NL2SVA-Human-17", "problem": "that the fifo output and read data are consistent, assuming no bypass. Use the signals 'rd_pop', 'rd_data', and 'fifo_out_data'.", "testbench": "module fifo_1r1w_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\n// ---- shift register code start ----\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\n// ---- read pointer/fifo empty code start ----\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\n// ---- fifo full and dout code start ----\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n       (rd_pop && (fifo_out_data != rd_data)) !== 1'b1\n);", "signals_for_validity": ["rd_pop", "fifo_out_data", "rd_data"]}
{"name": "FVEval-NL2SVA-Human-18", "problem": "that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_1r1w_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\n// ---- shift register code start ----\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\n// ---- read pointer/fifo empty code start ----\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\n// ---- fifo full and dout code start ----\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n       !fifo_empty |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "fifo_empty"]}
{"name": "FVEval-NL2SVA-Human-19", "problem": "that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.", "testbench": "module fifo_1r1w_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\n// ---- shift register code start ----\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\n// ---- read pointer/fifo empty code start ----\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\n// ---- fifo full and dout code start ----\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n       wr_push |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "wr_push"]}
{"name": "FVEval-NL2SVA-Human-20", "problem": "for forward progress: whenever there is a push, an output data pop eventually happens. Use the signals 'tb_push_cnt' and 'tb_pop_cnt'.", "testbench": "module multi_fifo_tb (\nclk,\nreset_,\nwr_vld,\nwr_data,\nwr_ready,\nrd_vld,\nrd_data,\nrd_ready\n);\n\n    parameter   max_fifo_entries = 4;\n    parameter   wr_port = 1;\n    parameter   rd_port = 1;\n    parameter   data_width = 1;\n\n    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );\n    localparam wr_port_log2 = $clog2(wr_port +1 );\n    localparam rand_bit_selector = $clog2(data_width);\n\n\ninput clk;\ninput reset_;\ninput [(wr_port)-1:0] wr_vld;\ninput [(data_width * wr_port)-1:0] wr_data;\ninput [(wr_port)-1:0] wr_ready;\ninput [(rd_port)-1:0] rd_vld;\ninput [(data_width * rd_port)-1:0] rd_data;\ninput [(rd_port)-1:0] rd_ready;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nreg [(fifo_entry_cntr-1):0] tb_wr_ptr;\nreg [(fifo_entry_cntr-1):0] tb_rd_ptr;\n\nreg [(wr_port - 1):0] tb_wr_data_for_fv;\nreg [(rd_port - 1):0] tb_rd_data_for_fv;\n\nreg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];\nreg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];\n\n\n\nwire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;\nwire tb_fifo_should_not_underflow_err;\nwire tb_filled_cnt_less_or_equal_max_entries_err;\nwire tb_fifo_should_not_overflow_err;\nwire [wr_port-1:0] tb_wr_vld_is_contiguous_err;\nwire [wr_port-1:0] tb_wr_ready_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_vld_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_ready_is_contiguous_err;\n\n\nwire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; \ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv\n    always_comb\n    begin\n        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv\n    always_comb\n    begin\n        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim\n    always_comb\n    begin\n        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim\n    always_comb\n    begin\n        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\nwire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);\nwire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);\nwire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;\n\nwire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        tb_wr_ptr <= 0;\n        tb_rd_ptr <= 0;\n    end else begin\n        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write\n        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr\n        end else begin\n        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read\n        end\n    end\nend\n\nreg registered_data;\nreg [(fifo_entry_cntr-1):0] registered_ptr;\nreg [(wr_port)-1:0] registered_data_next;\nreg [(wr_port)-1:0] registered_data_update;\n\nreg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];\nreg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        registered_ptr <= 'x;                 // registered_ptr is random during reset\n    end else begin\n        registered_ptr <= registered_ptr;     // else it retiains its value\n    end\nend\n\n// when wr_ptr == registered_ptr, register data\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin:register_write_data\n    always_comb\n    begin\n        registered_data_next[i] = 0;\n        registered_data_update[i] = 0;\n        tb_random_bit_selector_next[i] = 0;\n        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin\n            registered_data_update[i] = 1;\n            registered_data_next[i] = tb_wr_data_for_fv[i];\n            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];\n        end\n    end\nend\nendgenerate\n\n// register selector\nreg [wr_port_log2-1:0] wr_index;\nreg [rand_bit_selector-1:0] tb_random_bit_next;\nalways_comb begin\n    tb_random_bit_next = 0;\n    for (wr_index=0; wr_index < wr_port; wr_index++) begin\n        if (registered_data_update[wr_index]) begin\n            tb_random_bit_next = tb_random_bit_selector_next[wr_index];\n        end\n    end\nend\n\n// register data\nalways @ (posedge clk)\nbegin\n    if (|registered_data_update) begin\n        registered_data <= |registered_data_next;\n        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;\n    end\nend\n\nreg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];\nreg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];\nreg [(fifo_entry_cntr-1):0] tb_shift;\n\nreg [(fifo_entry_cntr-1):0] n;\nalways @ (posedge clk)\nbegin\nif (tb_shift == 0) \n    for (n=0; n < max_fifo_entries; n++) begin\n        fifo_data_tracker[n] <= fifo_data_tracker_next[n];\n    end\nelse if (tb_shift > (max_fifo_entries+wr_port-1)) begin\n  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;\nend else begin\n    for (n=0; n<max_fifo_entries; n++) begin \n        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin\n          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];\n        end\n    end  \nend\nend     \n\ngenerate\nfor (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next\n    always_comb\n    begin\n        if (i<tb_fifo_filled_cnt) begin\n        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data\n        end\n        else if (i <tb_fifo_filled_cnt + wr_port) begin\n        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data\n        end\n        // else dont care\n    end\nend\nendgenerate\n\nalways_comb\nbegin\n    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;\n    end else begin\n        tb_shift = tb_pop_cnt;\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property(@(posedge clk) disable iff (tb_reset)\n    (|tb_push_cnt) |-> strong(##[0:$] |tb_pop_cnt)\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-21", "problem": "for forward progress: whenever FIFO becomes full, an output data pop eventually happens. Use the signals 'tb_fifo_filled_cnt' and 'tb_pop_cnt'.", "testbench": "module multi_fifo_tb (\nclk,\nreset_,\nwr_vld,\nwr_data,\nwr_ready,\nrd_vld,\nrd_data,\nrd_ready\n);\n\n    parameter   max_fifo_entries = 4;\n    parameter   wr_port = 1;\n    parameter   rd_port = 1;\n    parameter   data_width = 1;\n\n    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );\n    localparam wr_port_log2 = $clog2(wr_port +1 );\n    localparam rand_bit_selector = $clog2(data_width);\n\n\ninput clk;\ninput reset_;\ninput [(wr_port)-1:0] wr_vld;\ninput [(data_width * wr_port)-1:0] wr_data;\ninput [(wr_port)-1:0] wr_ready;\ninput [(rd_port)-1:0] rd_vld;\ninput [(data_width * rd_port)-1:0] rd_data;\ninput [(rd_port)-1:0] rd_ready;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nreg [(fifo_entry_cntr-1):0] tb_wr_ptr;\nreg [(fifo_entry_cntr-1):0] tb_rd_ptr;\n\nreg [(wr_port - 1):0] tb_wr_data_for_fv;\nreg [(rd_port - 1):0] tb_rd_data_for_fv;\n\nreg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];\nreg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];\n\n\n\nwire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;\nwire tb_fifo_should_not_underflow_err;\nwire tb_filled_cnt_less_or_equal_max_entries_err;\nwire tb_fifo_should_not_overflow_err;\nwire [wr_port-1:0] tb_wr_vld_is_contiguous_err;\nwire [wr_port-1:0] tb_wr_ready_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_vld_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_ready_is_contiguous_err;\n\n\nwire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; \ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv\n    always_comb\n    begin\n        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv\n    always_comb\n    begin\n        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim\n    always_comb\n    begin\n        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim\n    always_comb\n    begin\n        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\nwire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);\nwire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);\nwire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;\n\nwire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        tb_wr_ptr <= 0;\n        tb_rd_ptr <= 0;\n    end else begin\n        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write\n        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr\n        end else begin\n        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read\n        end\n    end\nend\n\nreg registered_data;\nreg [(fifo_entry_cntr-1):0] registered_ptr;\nreg [(wr_port)-1:0] registered_data_next;\nreg [(wr_port)-1:0] registered_data_update;\n\nreg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];\nreg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        registered_ptr <= 'x;                 // registered_ptr is random during reset\n    end else begin\n        registered_ptr <= registered_ptr;     // else it retiains its value\n    end\nend\n\n// when wr_ptr == registered_ptr, register data\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin:register_write_data\n    always_comb\n    begin\n        registered_data_next[i] = 0;\n        registered_data_update[i] = 0;\n        tb_random_bit_selector_next[i] = 0;\n        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin\n            registered_data_update[i] = 1;\n            registered_data_next[i] = tb_wr_data_for_fv[i];\n            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];\n        end\n    end\nend\nendgenerate\n\n// register selector\nreg [wr_port_log2-1:0] wr_index;\nreg [rand_bit_selector-1:0] tb_random_bit_next;\nalways_comb begin\n    tb_random_bit_next = 0;\n    for (wr_index=0; wr_index < wr_port; wr_index++) begin\n        if (registered_data_update[wr_index]) begin\n            tb_random_bit_next = tb_random_bit_selector_next[wr_index];\n        end\n    end\nend\n\n// register data\nalways @ (posedge clk)\nbegin\n    if (|registered_data_update) begin\n        registered_data <= |registered_data_next;\n        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;\n    end\nend\n\nreg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];\nreg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];\nreg [(fifo_entry_cntr-1):0] tb_shift;\n\nreg [(fifo_entry_cntr-1):0] n;\nalways @ (posedge clk)\nbegin\nif (tb_shift == 0) \n    for (n=0; n < max_fifo_entries; n++) begin\n        fifo_data_tracker[n] <= fifo_data_tracker_next[n];\n    end\nelse if (tb_shift > (max_fifo_entries+wr_port-1)) begin\n  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;\nend else begin\n    for (n=0; n<max_fifo_entries; n++) begin \n        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin\n          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];\n        end\n    end  \nend\nend     \n\ngenerate\nfor (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next\n    always_comb\n    begin\n        if (i<tb_fifo_filled_cnt) begin\n        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data\n        end\n        else if (i <tb_fifo_filled_cnt + wr_port) begin\n        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data\n        end\n        // else dont care\n    end\nend\nendgenerate\n\nalways_comb\nbegin\n    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;\n    end else begin\n        tb_shift = tb_pop_cnt;\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    tb_fifo_filled_cnt == max_fifo_entries |-> ##[0:$] tb_pop_cnt > 0\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-22", "problem": "that the pop count is never greater than current filled count. Use the signals 'tb_fifo_filled_cnt' and 'tb_pop_cnt'.", "testbench": "module multi_fifo_tb (\nclk,\nreset_,\nwr_vld,\nwr_data,\nwr_ready,\nrd_vld,\nrd_data,\nrd_ready\n);\n\n    parameter   max_fifo_entries = 4;\n    parameter   wr_port = 1;\n    parameter   rd_port = 1;\n    parameter   data_width = 1;\n\n    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );\n    localparam wr_port_log2 = $clog2(wr_port +1 );\n    localparam rand_bit_selector = $clog2(data_width);\n\n\ninput clk;\ninput reset_;\ninput [(wr_port)-1:0] wr_vld;\ninput [(data_width * wr_port)-1:0] wr_data;\ninput [(wr_port)-1:0] wr_ready;\ninput [(rd_port)-1:0] rd_vld;\ninput [(data_width * rd_port)-1:0] rd_data;\ninput [(rd_port)-1:0] rd_ready;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nreg [(fifo_entry_cntr-1):0] tb_wr_ptr;\nreg [(fifo_entry_cntr-1):0] tb_rd_ptr;\n\nreg [(wr_port - 1):0] tb_wr_data_for_fv;\nreg [(rd_port - 1):0] tb_rd_data_for_fv;\n\nreg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];\nreg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];\n\n\n\nwire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;\nwire tb_fifo_should_not_underflow_err;\nwire tb_filled_cnt_less_or_equal_max_entries_err;\nwire tb_fifo_should_not_overflow_err;\nwire [wr_port-1:0] tb_wr_vld_is_contiguous_err;\nwire [wr_port-1:0] tb_wr_ready_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_vld_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_ready_is_contiguous_err;\n\n\nwire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; \ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv\n    always_comb\n    begin\n        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv\n    always_comb\n    begin\n        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim\n    always_comb\n    begin\n        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim\n    always_comb\n    begin\n        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\nwire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);\nwire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);\nwire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;\n\nwire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        tb_wr_ptr <= 0;\n        tb_rd_ptr <= 0;\n    end else begin\n        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write\n        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr\n        end else begin\n        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read\n        end\n    end\nend\n\nreg registered_data;\nreg [(fifo_entry_cntr-1):0] registered_ptr;\nreg [(wr_port)-1:0] registered_data_next;\nreg [(wr_port)-1:0] registered_data_update;\n\nreg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];\nreg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        registered_ptr <= 'x;                 // registered_ptr is random during reset\n    end else begin\n        registered_ptr <= registered_ptr;     // else it retiains its value\n    end\nend\n\n// when wr_ptr == registered_ptr, register data\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin:register_write_data\n    always_comb\n    begin\n        registered_data_next[i] = 0;\n        registered_data_update[i] = 0;\n        tb_random_bit_selector_next[i] = 0;\n        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin\n            registered_data_update[i] = 1;\n            registered_data_next[i] = tb_wr_data_for_fv[i];\n            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];\n        end\n    end\nend\nendgenerate\n\n// register selector\nreg [wr_port_log2-1:0] wr_index;\nreg [rand_bit_selector-1:0] tb_random_bit_next;\nalways_comb begin\n    tb_random_bit_next = 0;\n    for (wr_index=0; wr_index < wr_port; wr_index++) begin\n        if (registered_data_update[wr_index]) begin\n            tb_random_bit_next = tb_random_bit_selector_next[wr_index];\n        end\n    end\nend\n\n// register data\nalways @ (posedge clk)\nbegin\n    if (|registered_data_update) begin\n        registered_data <= |registered_data_next;\n        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;\n    end\nend\n\nreg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];\nreg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];\nreg [(fifo_entry_cntr-1):0] tb_shift;\n\nreg [(fifo_entry_cntr-1):0] n;\nalways @ (posedge clk)\nbegin\nif (tb_shift == 0) \n    for (n=0; n < max_fifo_entries; n++) begin\n        fifo_data_tracker[n] <= fifo_data_tracker_next[n];\n    end\nelse if (tb_shift > (max_fifo_entries+wr_port-1)) begin\n  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;\nend else begin\n    for (n=0; n<max_fifo_entries; n++) begin \n        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin\n          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];\n        end\n    end  \nend\nend     \n\ngenerate\nfor (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next\n    always_comb\n    begin\n        if (i<tb_fifo_filled_cnt) begin\n        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data\n        end\n        else if (i <tb_fifo_filled_cnt + wr_port) begin\n        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data\n        end\n        // else dont care\n    end\nend\nendgenerate\n\nalways_comb\nbegin\n    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;\n    end else begin\n        tb_shift = tb_pop_cnt;\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_pop_cnt > tb_fifo_filled_cnt) !== 1'b1\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-23", "problem": "that the filled count is less than or equal to maximum allowed entires in the FIFO. Use the signal 'tb_fifo_filled_cnt'.", "testbench": "module multi_fifo_tb (\nclk,\nreset_,\nwr_vld,\nwr_data,\nwr_ready,\nrd_vld,\nrd_data,\nrd_ready\n);\n\n    parameter   max_fifo_entries = 4;\n    parameter   wr_port = 1;\n    parameter   rd_port = 1;\n    parameter   data_width = 1;\n\n    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );\n    localparam wr_port_log2 = $clog2(wr_port +1 );\n    localparam rand_bit_selector = $clog2(data_width);\n\n\ninput clk;\ninput reset_;\ninput [(wr_port)-1:0] wr_vld;\ninput [(data_width * wr_port)-1:0] wr_data;\ninput [(wr_port)-1:0] wr_ready;\ninput [(rd_port)-1:0] rd_vld;\ninput [(data_width * rd_port)-1:0] rd_data;\ninput [(rd_port)-1:0] rd_ready;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nreg [(fifo_entry_cntr-1):0] tb_wr_ptr;\nreg [(fifo_entry_cntr-1):0] tb_rd_ptr;\n\nreg [(wr_port - 1):0] tb_wr_data_for_fv;\nreg [(rd_port - 1):0] tb_rd_data_for_fv;\n\nreg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];\nreg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];\n\n\n\nwire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;\nwire tb_fifo_should_not_underflow_err;\nwire tb_filled_cnt_less_or_equal_max_entries_err;\nwire tb_fifo_should_not_overflow_err;\nwire [wr_port-1:0] tb_wr_vld_is_contiguous_err;\nwire [wr_port-1:0] tb_wr_ready_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_vld_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_ready_is_contiguous_err;\n\n\nwire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; \ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv\n    always_comb\n    begin\n        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv\n    always_comb\n    begin\n        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim\n    always_comb\n    begin\n        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim\n    always_comb\n    begin\n        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\nwire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);\nwire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);\nwire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;\n\nwire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        tb_wr_ptr <= 0;\n        tb_rd_ptr <= 0;\n    end else begin\n        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write\n        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr\n        end else begin\n        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read\n        end\n    end\nend\n\nreg registered_data;\nreg [(fifo_entry_cntr-1):0] registered_ptr;\nreg [(wr_port)-1:0] registered_data_next;\nreg [(wr_port)-1:0] registered_data_update;\n\nreg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];\nreg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        registered_ptr <= 'x;                 // registered_ptr is random during reset\n    end else begin\n        registered_ptr <= registered_ptr;     // else it retiains its value\n    end\nend\n\n// when wr_ptr == registered_ptr, register data\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin:register_write_data\n    always_comb\n    begin\n        registered_data_next[i] = 0;\n        registered_data_update[i] = 0;\n        tb_random_bit_selector_next[i] = 0;\n        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin\n            registered_data_update[i] = 1;\n            registered_data_next[i] = tb_wr_data_for_fv[i];\n            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];\n        end\n    end\nend\nendgenerate\n\n// register selector\nreg [wr_port_log2-1:0] wr_index;\nreg [rand_bit_selector-1:0] tb_random_bit_next;\nalways_comb begin\n    tb_random_bit_next = 0;\n    for (wr_index=0; wr_index < wr_port; wr_index++) begin\n        if (registered_data_update[wr_index]) begin\n            tb_random_bit_next = tb_random_bit_selector_next[wr_index];\n        end\n    end\nend\n\n// register data\nalways @ (posedge clk)\nbegin\n    if (|registered_data_update) begin\n        registered_data <= |registered_data_next;\n        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;\n    end\nend\n\nreg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];\nreg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];\nreg [(fifo_entry_cntr-1):0] tb_shift;\n\nreg [(fifo_entry_cntr-1):0] n;\nalways @ (posedge clk)\nbegin\nif (tb_shift == 0) \n    for (n=0; n < max_fifo_entries; n++) begin\n        fifo_data_tracker[n] <= fifo_data_tracker_next[n];\n    end\nelse if (tb_shift > (max_fifo_entries+wr_port-1)) begin\n  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;\nend else begin\n    for (n=0; n<max_fifo_entries; n++) begin \n        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin\n          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];\n        end\n    end  \nend\nend     \n\ngenerate\nfor (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next\n    always_comb\n    begin\n        if (i<tb_fifo_filled_cnt) begin\n        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data\n        end\n        else if (i <tb_fifo_filled_cnt + wr_port) begin\n        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data\n        end\n        // else dont care\n    end\nend\nendgenerate\n\nalways_comb\nbegin\n    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;\n    end else begin\n        tb_shift = tb_pop_cnt;\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_fifo_filled_cnt > max_fifo_entries) !== 1'b1\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-24", "problem": "that the FIFO does not experience overflow. Use the signals 'tb_push_cnt', 'tb_pop_cnt', and 'tb_fifo_filled_cnt'.", "testbench": "module multi_fifo_tb (\nclk,\nreset_,\nwr_vld,\nwr_data,\nwr_ready,\nrd_vld,\nrd_data,\nrd_ready\n);\n\n    parameter   max_fifo_entries = 4;\n    parameter   wr_port = 1;\n    parameter   rd_port = 1;\n    parameter   data_width = 1;\n\n    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );\n    localparam wr_port_log2 = $clog2(wr_port +1 );\n    localparam rand_bit_selector = $clog2(data_width);\n\n\ninput clk;\ninput reset_;\ninput [(wr_port)-1:0] wr_vld;\ninput [(data_width * wr_port)-1:0] wr_data;\ninput [(wr_port)-1:0] wr_ready;\ninput [(rd_port)-1:0] rd_vld;\ninput [(data_width * rd_port)-1:0] rd_data;\ninput [(rd_port)-1:0] rd_ready;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nreg [(fifo_entry_cntr-1):0] tb_wr_ptr;\nreg [(fifo_entry_cntr-1):0] tb_rd_ptr;\n\nreg [(wr_port - 1):0] tb_wr_data_for_fv;\nreg [(rd_port - 1):0] tb_rd_data_for_fv;\n\nreg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];\nreg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];\n\n\n\nwire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;\nwire tb_fifo_should_not_underflow_err;\nwire tb_filled_cnt_less_or_equal_max_entries_err;\nwire tb_fifo_should_not_overflow_err;\nwire [wr_port-1:0] tb_wr_vld_is_contiguous_err;\nwire [wr_port-1:0] tb_wr_ready_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_vld_is_contiguous_err;\nwire [rd_port-1:0] tb_rd_ready_is_contiguous_err;\n\n\nwire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; \ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv\n    always_comb\n    begin\n        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv\n    always_comb\n    begin\n        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim\n    always_comb\n    begin\n        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\ngenerate\nfor (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim\n    always_comb\n    begin\n        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];\n    end\nend\nendgenerate\n\nwire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);\nwire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);\nwire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;\n\nwire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        tb_wr_ptr <= 0;\n        tb_rd_ptr <= 0;\n    end else begin\n        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write\n        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr\n        end else begin\n        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read\n        end\n    end\nend\n\nreg registered_data;\nreg [(fifo_entry_cntr-1):0] registered_ptr;\nreg [(wr_port)-1:0] registered_data_next;\nreg [(wr_port)-1:0] registered_data_update;\n\nreg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];\nreg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;\n\nalways @(posedge clk)\nbegin\n    if (!reset_) begin\n        registered_ptr <= 'x;                 // registered_ptr is random during reset\n    end else begin\n        registered_ptr <= registered_ptr;     // else it retiains its value\n    end\nend\n\n// when wr_ptr == registered_ptr, register data\ngenerate\nfor (genvar i=0; i<wr_port; i++) begin:register_write_data\n    always_comb\n    begin\n        registered_data_next[i] = 0;\n        registered_data_update[i] = 0;\n        tb_random_bit_selector_next[i] = 0;\n        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin\n            registered_data_update[i] = 1;\n            registered_data_next[i] = tb_wr_data_for_fv[i];\n            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];\n        end\n    end\nend\nendgenerate\n\n// register selector\nreg [wr_port_log2-1:0] wr_index;\nreg [rand_bit_selector-1:0] tb_random_bit_next;\nalways_comb begin\n    tb_random_bit_next = 0;\n    for (wr_index=0; wr_index < wr_port; wr_index++) begin\n        if (registered_data_update[wr_index]) begin\n            tb_random_bit_next = tb_random_bit_selector_next[wr_index];\n        end\n    end\nend\n\n// register data\nalways @ (posedge clk)\nbegin\n    if (|registered_data_update) begin\n        registered_data <= |registered_data_next;\n        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;\n    end\nend\n\nreg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];\nreg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];\nreg [(fifo_entry_cntr-1):0] tb_shift;\n\nreg [(fifo_entry_cntr-1):0] n;\nalways @ (posedge clk)\nbegin\nif (tb_shift == 0) \n    for (n=0; n < max_fifo_entries; n++) begin\n        fifo_data_tracker[n] <= fifo_data_tracker_next[n];\n    end\nelse if (tb_shift > (max_fifo_entries+wr_port-1)) begin\n  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;\nend else begin\n    for (n=0; n<max_fifo_entries; n++) begin \n        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin\n          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];\n        end\n    end  \nend\nend     \n\ngenerate\nfor (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next\n    always_comb\n    begin\n        if (i<tb_fifo_filled_cnt) begin\n        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data\n        end\n        else if (i <tb_fifo_filled_cnt + wr_port) begin\n        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data\n        end\n        // else dont care\n    end\nend\nendgenerate\n\nalways_comb\nbegin\n    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin\n        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;\n    end else begin\n        tb_shift = tb_pop_cnt;\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    |((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) !== 1'b1\n);", "signals_for_validity": ["[2:0] tb_push_cnt", "[2:0] tb_pop_cnt", "[2:0] tb_fifo_filled_cnt"]}
{"name": "FVEval-NL2SVA-Human-25", "problem": "that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !($onehot0(tb_gnt)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-26", "problem": "that if there is a req, there is a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-27", "problem": "that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_gnt & ~tb_req) == 0\n);", "signals_for_validity": ["[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-28", "problem": "that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt', 'hold', 'busy', and 'last_gnt'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_gnt && busy) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-29", "problem": "that the arbiter holds onto grants when there is hold and the arbiter is not busy. Use the signals 'busy', 'tb_gnt', 'hold', and 'last_gnt'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 \n);", "signals_for_validity": ["hold", "[5:0] tb_gnt", "busy", "[5:0] last_gnt"]}
{"name": "FVEval-NL2SVA-Human-30", "problem": "that the given arbiter follows the Round Robin policy: start with 0th client and keep granting from 0 to n clients one by one except those that are not requesting, then wrap around. Use the signals 'tb_gnt','last_gnt', 'hold', 'valid_request_mask_rr', and 'tb_req'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|last_gnt && |tb_gnt && !hold && (|(valid_request_mask_rr & tb_req))) !== 1'b1\n);", "signals_for_validity": ["[5:0] valid_request_mask_rr", "[5:0] last_gnt", "[5:0] tb_req", "hold", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-31", "problem": "that the first grant of the arbiter follows the Round Robin policy: start with 0th client and keep granting from 0 to n clients one by one except those that are not requesting, then wrap around. Use the signals 'tb_gnt','last_gnt', 'hold', and 'tb_req'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    ((last_gnt === 'd0) && |tb_gnt && ( ((tb_gnt-'d1) & tb_req) !== 'd0)) !== 1'b1\n);", "signals_for_validity": ["[5:0] last_gnt", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-32", "problem": "that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'cont_gnt', 'busy' and 'hold'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !$onehot0({hold,busy,cont_gnt}) !== 1'b1\n);", "signals_for_validity": ["hold", "busy", "cont_gnt"]}
{"name": "FVEval-NL2SVA-Human-34", "problem": "that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.", "testbench": "module arbiter_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width:0] gnt_id; // Binary encoded ID of the granted client. 0 indicates no grant. Client numbering starts from 1.\ninput cont_gnt; //same as cont_gnt from arbgen\n\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1\n);", "signals_for_validity": ["[2:0] gnt_id", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-35", "problem": "that the specified fsm_sequence is never seen. Use the signal 'tb_sequence_seen'.", "testbench": "module fsm_sequence_tb (\nclk, \nreset_, \nfsm_state,\nfsm_sequence\n);\n    parameter fsm_width = 2; //actual width of the states in the RTL\n    parameter num_of_states=2; //number of states provided in the fsm_sequence\n    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the \"fsm_sequence\" is repeated in the \"fsm_sequence\"  \n\ninput clk;\ninput reset_;\ninput [fsm_width-1:0]fsm_state;\ninput [fsm_width*num_of_states-1:0]fsm_sequence;\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; \n\n//match the current \"fsm_state\" with the states provided in the \"fsm_sequence\"\nwire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; \nreg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; \n\n//Track all the states of the \"fsm_sequence\"\nreg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; \n\nreg [fsm_width-1:0] fsm_state_d1;\nreg tb_reset_d1;\nwire [fsm_width-1:0] tb_random_state;\nwire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;\n\n\n//storing the states of the fsm_sequence in the correct order\nfor (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states\n    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];\nend\n\n//Delayed versions of fsm_state and tb_reset\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fsm_state_d1 <= 'd0;\n        tb_reset_d1 <= 1;\n    end else begin\n        fsm_state_d1 <= fsm_state;\n        tb_reset_d1 <= tb_reset;  \n    end\nend\n\nfor (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat\n    if (n==0) begin : matching_of_states_for_certain_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n                assign match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);\n            end else begin : matching_of_states_for_other_states \n                assign match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);\n            end\n        end \n    end else begin : matching_of_states_for_other_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n            assign match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) \n                                            : match_tracker[n][0] ;\n            end else begin : matching_of_states_for_other_states\n            assign match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) \n                                            : match_tracker[n][i] ;\n            end\n        end \n    end\nend\n\nreg [$clog2(num_of_times_initial_state_repeats):0] j;\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            state_tracker[j] <= 'd0;\n            match_tracker_d1[j] <= 'd0;\n        end\n    end else begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            match_tracker_d1[j] <= match_tracker[j];\n            if (j==0) \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                        ? state_tracker[j]|match_tracker[j] \n                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) \n                                            ? 'd1 \n                                            : 'd0\n                                        );\n            else \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                    ? state_tracker[j]|match_tracker[j] \n                                    : 'd0;\n        end\n    end\nend\n\nfor (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : fsm_sequence_seen\n    assign tb_sequence_seen[n] = state_tracker[n][num_of_states-1];\nend\n\nreg check_state_legal_precondition;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        check_state_legal_precondition <= 1'b0;\n    end else begin\n        check_state_legal_precondition <= fsm_state == tb_fsm_sequence[0];\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_sequence_seen) !== 1'b1     \n);", "signals_for_validity": ["tb_sequence_seen"]}
{"name": "FVEval-NL2SVA-Human-37", "problem": "that for any random state, the FSM should not remain in the same state in the next cycle. Use the signals 'fsm_state' and 'tb_random_state'.", "testbench": "module fsm_sequence_tb (\nclk, \nreset_, \nfsm_state,\nfsm_sequence\n);\n    parameter fsm_width = 2; //actual width of the states in the RTL\n    parameter num_of_states=2; //number of states provided in the fsm_sequence\n    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the \"fsm_sequence\" is repeated in the \"fsm_sequence\"  \n\ninput clk;\ninput reset_;\ninput [fsm_width-1:0]fsm_state;\ninput [fsm_width*num_of_states-1:0]fsm_sequence;\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; \n\n//match the current \"fsm_state\" with the states provided in the \"fsm_sequence\"\nwire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; \nreg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; \n\n//Track all the states of the \"fsm_sequence\"\nreg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; \n\nreg [fsm_width-1:0] fsm_state_d1;\nreg tb_reset_d1;\nwire [fsm_width-1:0] tb_random_state;\nwire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;\n\n\n//storing the states of the fsm_sequence in the correct order\nfor (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states\n    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];\nend\n\n//Delayed versions of fsm_state and tb_reset\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fsm_state_d1 <= 'd0;\n        tb_reset_d1 <= 1;\n    end else begin\n        fsm_state_d1 <= fsm_state;\n        tb_reset_d1 <= tb_reset;  \n    end\nend\n\nfor (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat\n    if (n==0) begin : matching_of_states_for_certain_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n                assign match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);\n            end else begin : matching_of_states_for_other_states \n                assign match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);\n            end\n        end \n    end else begin : matching_of_states_for_other_cases\n        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states\n            if (i==0) begin : matching_of_states_for_first_state \n            assign match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) \n                                            : match_tracker[n][0] ;\n            end else begin : matching_of_states_for_other_states\n            assign match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) \n                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) \n                                            : match_tracker[n][i] ;\n            end\n        end \n    end\nend\n\nreg [$clog2(num_of_times_initial_state_repeats):0] j;\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            state_tracker[j] <= 'd0;\n            match_tracker_d1[j] <= 'd0;\n        end\n    end else begin\n        for (j=0; j< num_of_times_initial_state_repeats; j++) begin\n            match_tracker_d1[j] <= match_tracker[j];\n            if (j==0) \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                        ? state_tracker[j]|match_tracker[j] \n                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) \n                                            ? 'd1 \n                                            : 'd0\n                                        );\n            else \n            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || \n                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && \n                                    (|match_tracker[j] != 'd0)) \n                                    ? state_tracker[j]|match_tracker[j] \n                                    : 'd0;\n        end\n    end\nend\n\nfor (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : fsm_sequence_seen\n    assign tb_sequence_seen[n] = state_tracker[n][num_of_states-1];\nend\n\nreg check_state_legal_precondition;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        check_state_legal_precondition <= 1'b0;\n    end else begin\n        check_state_legal_precondition <= fsm_state == tb_fsm_sequence[0];\n    end\nend\n\nendmodule", "ground_truth": "asrt: assert property (\n    @(posedge clk) disable iff (tb_reset)\n    (fsm_state == tb_random_state) |=> (fsm_state != $past(fsm_state))\n);", "signals_for_validity": ["[1:0] fsm_state", "[1:0] tb_random_state"]}
{"name": "FVEval-NL2SVA-Human-38", "problem": "that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !($onehot0(tb_gnt)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-39", "problem": "that if there is a req, there is a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-40", "problem": "that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_gnt & ~tb_req) == 0\n);", "signals_for_validity": ["[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-41", "problem": "that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt' and 'busy'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_gnt && busy) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-42", "problem": "that the arbiter holds onto grants when there is hold and the arbiter is not busy. Use the signals 'busy', 'hold', 'tb_gnt' and 'last_gnt'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 \n);", "signals_for_validity": ["[5:0] tb_gnt", "[5:0] last_gnt", "busy", "hold"]}
{"name": "FVEval-NL2SVA-Human-43", "problem": "that no grants are given while there is a grant bubble. Use the signals 'tb_gnt', 'tb_req', 'sticky_req', and 'arbiter_in_sticky'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n(arbiter_in_sticky && !(|(sticky_req & tb_req)) && (tb_gnt != 'd0)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_req", "[5:0] tb_gnt", "[5:0] sticky_req", "arbiter_in_sticky"]}
{"name": "FVEval-NL2SVA-Human-44", "problem": "that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client. Use the signals 'tb_gnt', 'sticky_req', and 'arbiter_in_sticky'", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (arbiter_in_sticky && (tb_gnt != sticky_req)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt", "[5:0] sticky_req", "arbiter_in_sticky"]}
{"name": "FVEval-NL2SVA-Human-45", "problem": "that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'hold', 'cont_gnt' and 'busy'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !$onehot0({hold,busy,cont_gnt}) !== 1'b1\n);", "signals_for_validity": ["hold", "busy", "cont_gnt"]}
{"name": "FVEval-NL2SVA-Human-47", "problem": "that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.", "testbench": "module arbiter_sticky_rr_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width:0] gnt_id; // Binary encoded ID of the granted client. 0 indicates no grant. Client numbering starts from 1.\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nwire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (\n                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :\n                                                ~tb_gnt);\n\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\ngenvar i;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1\n);", "signals_for_validity": ["[2:0] gnt_id", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-48", "problem": "that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nwire colour_1bit;                          // pattern\nwire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only\nasum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)\n$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)\n);\nreg [FIFO_DEPTH_log2:0] rd_pending_ctr; \nreg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead\nreg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead\nwire fifo_empty;\nalways @(posedge clk) begin\n    // ---- input fsm ----\n    if (!reset_) begin\n        input_fsm <= 2'd0;\n    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        input_fsm <= 2'd1; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        input_fsm <= 2'd2; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        input_fsm <= 2'd3; \n    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        input_fsm <= 2'd3; \n    end else begin\n        input_fsm <= input_fsm; \n    end\n    // ---- output fsm ----\n    if (!reset_) begin\n        output_fsm <= 2'd0;\n    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        output_fsm <= 2'd1; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        output_fsm <= 2'd2; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        output_fsm <= 2'd3; \n    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        output_fsm <= 2'd3; \n    end else begin\n        output_fsm <= output_fsm; \n    end\n    // ---- pending counter ----\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\nend\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_empty && rd_pop) !== 1'b1\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-49", "problem": "that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nwire colour_1bit;                          // pattern\nwire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only\nasum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)\n$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)\n);\nreg [FIFO_DEPTH_log2:0] rd_pending_ctr; \nreg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead\nreg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead\nwire fifo_empty;\nalways @(posedge clk) begin\n    // ---- input fsm ----\n    if (!reset_) begin\n        input_fsm <= 2'd0;\n    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        input_fsm <= 2'd1; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        input_fsm <= 2'd2; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        input_fsm <= 2'd3; \n    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        input_fsm <= 2'd3; \n    end else begin\n        input_fsm <= input_fsm; \n    end\n    // ---- output fsm ----\n    if (!reset_) begin\n        output_fsm <= 2'd0;\n    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        output_fsm <= 2'd1; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        output_fsm <= 2'd2; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        output_fsm <= 2'd3; \n    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        output_fsm <= 2'd3; \n    end else begin\n        output_fsm <= output_fsm; \n    end\n    // ---- pending counter ----\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\nend\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_full && wr_push) !== 1'b1\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-51", "problem": "that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nwire colour_1bit;                          // pattern\nwire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only\nasum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)\n$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)\n);\nreg [FIFO_DEPTH_log2:0] rd_pending_ctr; \nreg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead\nreg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead\nwire fifo_empty;\nalways @(posedge clk) begin\n    // ---- input fsm ----\n    if (!reset_) begin\n        input_fsm <= 2'd0;\n    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        input_fsm <= 2'd1; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        input_fsm <= 2'd2; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        input_fsm <= 2'd3; \n    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        input_fsm <= 2'd3; \n    end else begin\n        input_fsm <= input_fsm; \n    end\n    // ---- output fsm ----\n    if (!reset_) begin\n        output_fsm <= 2'd0;\n    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        output_fsm <= 2'd1; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        output_fsm <= 2'd2; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        output_fsm <= 2'd3; \n    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        output_fsm <= 2'd3; \n    end else begin\n        output_fsm <= output_fsm; \n    end\n    // ---- pending counter ----\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\nend\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !fifo_empty |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-52", "problem": "that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nwire colour_1bit;                          // pattern\nwire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only\nasum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)\n$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)\n);\nreg [FIFO_DEPTH_log2:0] rd_pending_ctr; \nreg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead\nreg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead\nwire fifo_empty;\nalways @(posedge clk) begin\n    // ---- input fsm ----\n    if (!reset_) begin\n        input_fsm <= 2'd0;\n    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        input_fsm <= 2'd1; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        input_fsm <= 2'd2; \n    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        input_fsm <= 2'd3; \n    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        input_fsm <= 2'd3; \n    end else begin\n        input_fsm <= input_fsm; \n    end\n    // ---- output fsm ----\n    if (!reset_) begin\n        output_fsm <= 2'd0;\n    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state\n        output_fsm <= 2'd1; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state\n        output_fsm <= 2'd2; \n    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state\n        output_fsm <= 2'd3; \n    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state\n        output_fsm <= 2'd3; \n    end else begin\n        output_fsm <= output_fsm; \n    end\n    // ---- pending counter ----\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\nend\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    wr_push |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-53", "problem": "that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !($onehot0(tb_gnt)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-54", "problem": "that if there is a req, there is a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-55", "problem": "that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (tb_gnt & ~tb_req) == 0\n);", "signals_for_validity": ["[5:0] tb_req", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-56", "problem": "that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt' and 'busy'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (|tb_gnt && busy) !== 1'b1\n);", "signals_for_validity": ["busy", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-57", "problem": "that the arbiter holds onto grants when there is hold and the arbiter is not busy. Use the signals 'busy', 'tb_gnt', 'hold', and 'last_gnt'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 \n);", "signals_for_validity": ["[5:0] tb_gnt", "[5:0] last_gnt", "busy", "hold"]}
{"name": "FVEval-NL2SVA-Human-58", "problem": "that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client. Use the signals 'tb_gnt', 'sticky_req', and 'arbiter_in_sticky'", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (arbiter_in_sticky && (tb_gnt != sticky_req)) !== 1'b1\n);", "signals_for_validity": ["[5:0] tb_gnt", "[5:0] sticky_req", "arbiter_in_sticky"]}
{"name": "FVEval-NL2SVA-Human-59", "problem": "that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'hold', 'cont_gnt' and 'busy'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width-1:0] gnt_id;\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !$onehot0({hold,busy,cont_gnt}) !== 1'b1\n);", "signals_for_validity": ["hold", "busy", "cont_gnt"]}
{"name": "FVEval-NL2SVA-Human-61", "problem": "that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.", "testbench": "module arbiter_sticky_lru_tb (\nclk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);\n\n    parameter       NUM_OF_CLIENTS = 6;\n\nlocalparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); \nlocalparam busy_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);\nlocalparam hold_latency_width = $clog2(NUM_OF_CLIENTS);\n\ninput clk;\ninput reset_;//clock and reset\ninput busy; //busy \ninput hold;//hold\ninput [NUM_OF_CLIENTS-1 : 0] req;\ninput [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.\ninput [tb_num_client_req_width:0] gnt_id; // Binary encoded ID of the granted client. 0 indicates no grant. Client numbering starts from 1.\ninput cont_gnt; //same as cont_gnt from arbgen\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\nwire [NUM_OF_CLIENTS-1 : 0] tb_req;\nwire [NUM_OF_CLIENTS-1 : 0] tb_gnt;\nwire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;\nwire [NUM_OF_CLIENTS-1 : 0] tb_hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] sticky_req;\nreg arbiter_in_sticky;\n\ngenvar a;\nassign tb_req = req;\nassign tb_gnt = gnt;\nassign tb_req_for_starvation = req;\nassign tb_hold = hold;\n\nreg [NUM_OF_CLIENTS-1 : 0] last_gnt;\nalways @(posedge clk) begin\n    if (!reset_) begin \n        last_gnt <= 0; \n   end else if (|tb_gnt && !cont_gnt) begin \n        last_gnt <= tb_gnt; \n    end\nend\n\n// sticky model    \nalways @(posedge clk) begin\n    if (!reset_) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end else if (|(tb_gnt & tb_req & tb_hold)) begin \n        arbiter_in_sticky <= 1'b1;\n        sticky_req <= tb_gnt & tb_req & tb_hold;\n    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin \n        arbiter_in_sticky <= 1'b0;\n        sticky_req <= 'd0;\n    end\nend    \n\nreg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];\nwire [tb_num_client_req_width:0] lru_gnt_num;\nreg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;\n\nassign lru_gnt_num = temp_lru_gnt_num_reg;\n\nalways_comb begin\n    temp_lru_gnt_num_reg = 'd0;\n    for (int k=0; k<NUM_OF_CLIENTS; k++) begin\n        if (tb_gnt[k]) begin\n            temp_lru_gnt_num_reg = lru[k];\n        end\n    end\nend\ngenvar i;\nreg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;\nfor (i = 0; i < NUM_OF_CLIENTS; i++) begin\n    always @(posedge clk) begin\n        if (!reset_) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end\n        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end\n    end\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1\n);", "signals_for_validity": ["[2:0] gnt_id", "[5:0] tb_gnt"]}
{"name": "FVEval-NL2SVA-Human-62", "problem": "that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks\nreg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter\nwire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next\nreg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data\nwire                     rand_pulse;                // random pulse which picks the packet\nreg                      rand_pulse_seen;           // to make sure we do this check only once\nwire                     fifo_empty;\n\nassign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        rand_pulse_seen <= 1'b0;\n    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin\n        rand_pulse_seen <= 1'b1;\n        free_selected_data <= wr_data;\n    end else begin\n        rand_pulse_seen <= rand_pulse_seen;\n        free_selected_data <= free_selected_data;\n    end\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        rand_packet_tracker <= 'd0;\n    end else begin\n        rand_packet_tracker <= rand_packet_tracker_next;\n    end\nend\n\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_empty && rd_pop) !== 1'b1\n);", "signals_for_validity": ["rd_pop", "fifo_empty"]}
{"name": "FVEval-NL2SVA-Human-63", "problem": "that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks\nreg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter\nwire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next\nreg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data\nwire                     rand_pulse;                // random pulse which picks the packet\nreg                      rand_pulse_seen;           // to make sure we do this check only once\nwire                     fifo_empty;\n\nassign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        rand_pulse_seen <= 1'b0;\n    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin\n        rand_pulse_seen <= 1'b1;\n        free_selected_data <= wr_data;\n    end else begin\n        rand_pulse_seen <= rand_pulse_seen;\n        free_selected_data <= free_selected_data;\n    end\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        rand_packet_tracker <= 'd0;\n    end else begin\n        rand_packet_tracker <= rand_packet_tracker_next;\n    end\nend\n\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\n\nendmodule", "ground_truth": "asrt : assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_full && wr_push) !== 1'b1\n);", "signals_for_validity": ["wr_push", "fifo_full"]}
{"name": "FVEval-NL2SVA-Human-64", "problem": "that the fifo output and read data are consistent, assuming no bypass. Use the signals 'rd_pop', 'rd_data', 'rand_packet_tracker', 'rand_packet_tracker_next', 'free_selected_data', and 'rand_pulse_seen'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks\nreg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter\nwire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next\nreg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data\nwire                     rand_pulse;                // random pulse which picks the packet\nreg                      rand_pulse_seen;           // to make sure we do this check only once\nwire                     fifo_empty;\n\nassign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        rand_pulse_seen <= 1'b0;\n    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin\n        rand_pulse_seen <= 1'b1;\n        free_selected_data <= wr_data;\n    end else begin\n        rand_pulse_seen <= rand_pulse_seen;\n        free_selected_data <= free_selected_data;\n    end\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        rand_packet_tracker <= 'd0;\n    end else begin\n        rand_packet_tracker <= rand_packet_tracker_next;\n    end\nend\n\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n       (rd_pop && (free_selected_data != rd_data) && (rand_packet_tracker_next == 'd0) && (rand_packet_tracker != 'd0) && rand_pulse_seen) !== 1'b1\n);", "signals_for_validity": ["[2:0] rand_packet_tracker_next", "free_selected_data", "rd_data", "rd_pop", "[2:0] rand_packet_tracker", "rand_pulse_seen"]}
{"name": "FVEval-NL2SVA-Human-65", "problem": "that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks\nreg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter\nwire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next\nreg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data\nwire                     rand_pulse;                // random pulse which picks the packet\nreg                      rand_pulse_seen;           // to make sure we do this check only once\nwire                     fifo_empty;\n\nassign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        rand_pulse_seen <= 1'b0;\n    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin\n        rand_pulse_seen <= 1'b1;\n        free_selected_data <= wr_data;\n    end else begin\n        rand_pulse_seen <= rand_pulse_seen;\n        free_selected_data <= free_selected_data;\n    end\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        rand_packet_tracker <= 'd0;\n    end else begin\n        rand_packet_tracker <= rand_packet_tracker_next;\n    end\nend\n\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !fifo_empty |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "fifo_empty"]}
{"name": "FVEval-NL2SVA-Human-66", "problem": "that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.", "testbench": "module fifo_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks\nreg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter\nwire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next\nreg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data\nwire                     rand_pulse;                // random pulse which picks the packet\nreg                      rand_pulse_seen;           // to make sure we do this check only once\nwire                     fifo_empty;\n\nassign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;\nalways @(posedge clk) begin\n    if (!reset_) begin\n        rand_pulse_seen <= 1'b0;\n    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin\n        rand_pulse_seen <= 1'b1;\n        free_selected_data <= wr_data;\n    end else begin\n        rand_pulse_seen <= rand_pulse_seen;\n        free_selected_data <= free_selected_data;\n    end\n    if (!reset_) begin\n        rd_pending_ctr <= 'd0;\n    end else begin\n        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        rand_packet_tracker <= 'd0;\n    end else begin\n        rand_packet_tracker <= rand_packet_tracker_next;\n    end\nend\n\nassign fifo_full = rd_pending_ctr == (FIFO_DEPTH);\nassign fifo_empty = rd_pending_ctr == 'd0;\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    wr_push |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "wr_push"]}
{"name": "FVEval-NL2SVA-Human-67", "problem": "that the FIFO does not underflow, taking the bypass into account. Use the signals 'wr_data', 'fifo_empty', 'rd_pop', 'rd_data', and 'wr_push'.", "testbench": "module fifo_with_bypass_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_empty && rd_pop && (!wr_push || (wr_data != rd_data))) !== 1'b1\n);", "signals_for_validity": ["wr_push", "fifo_empty", "rd_data", "rd_pop", "wr_data"]}
{"name": "FVEval-NL2SVA-Human-68", "problem": "that the FIFO does not overflow, taking bypass into account. Use the signals 'wr_push', 'fifo_full', 'rd_pop'.", "testbench": "module fifo_with_bypass_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (fifo_full && wr_push && !rd_pop) !== 1'b1\n);", "signals_for_validity": ["rd_pop", "wr_push", "fifo_full"]}
{"name": "FVEval-NL2SVA-Human-69", "problem": "that the fifo output and read data are consistent, taking bypass into account. Use the signals 'rd_pop', 'rd_data', 'wr_push', 'wr_data', 'fifo_empty', and 'fifo_out_data'.", "testbench": "module fifo_with_bypass_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!fifo_empty && rd_pop && (fifo_out_data != rd_data)) || (fifo_empty && rd_pop && wr_push && (wr_data != rd_data)) !== 1'b1\n);", "signals_for_validity": ["wr_push", "fifo_empty", "rd_data", "rd_pop", "wr_data", "fifo_out_data"]}
{"name": "FVEval-NL2SVA-Human-70", "problem": "that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.", "testbench": "module fifo_with_bypass_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    !fifo_empty |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "fifo_empty"]}
{"name": "FVEval-NL2SVA-Human-71", "problem": "that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.", "testbench": "module fifo_with_bypass_tb (\n     clk,\n     reset_,\n     wr_vld,\n     wr_data,\n     wr_ready,\n     rd_vld,\n     rd_data,\n     rd_ready\n   );\n  \n    parameter   FIFO_DEPTH                              = 4;\n    parameter   DATA_WIDTH                              = 1;\n\nlocalparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); \nlocalparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); \n\n    input                   clk;\n    input                   reset_;\n    input                   wr_vld;\n    input  [DATA_WIDTH-1:0] wr_data;\n    input                   wr_ready;\n    input                   rd_vld;\n    input  [DATA_WIDTH-1:0] rd_data;\n    input                   rd_ready;\n\nwire wr_push;\nwire rd_pop;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire fifo_full;\nassign wr_push = wr_vld && wr_ready;\nassign rd_pop = rd_vld && rd_ready; \n\nreg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register\nreg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr\nwire                             actual_fifo_pop;             // actual pop == pop\nreg                              fifo_empty;                  // fifo empty\nwire [DATA_WIDTH-1:0]            fifo_out_data;               // dout\n\nalways @(posedge clk) begin\n    if (!reset_) fifo_array[0] <= 'd0;\n    else if (wr_push) begin\n        fifo_array[0] <= wr_data;\n    end else fifo_array[0] <= fifo_array[0];\nend\nfor (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id\n    always @(posedge clk) begin\n        if (!reset_) fifo_array[i] <= 'd0;\n        else if (wr_push) begin\n            fifo_array[i] <= fifo_array[i-1];\n        end else fifo_array[i] <= fifo_array[i];\n    end\nend\n\nalways @(posedge clk) begin\n    if (!reset_) begin\n        fifo_rd_ptr <= 'd0;\n    end else if (wr_push && fifo_empty)  begin\n        fifo_rd_ptr <= 'd0;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin\n        fifo_rd_ptr <= 'd0;\n    end else begin\n        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;\n    end\n    if (!reset_) begin\n        fifo_empty <= 'd1;\n    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin\n        fifo_empty <= 'd1;\n    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin\n        fifo_empty <= 'd0;\n    end\nend\nassign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;\nassign fifo_out_data = fifo_array[fifo_rd_ptr];\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    wr_push |-> strong(##[0:$] rd_pop)\n);", "signals_for_validity": ["rd_pop", "wr_push"]}
{"name": "FVEval-NL2SVA-Human-72", "problem": "read address is not greater than number of entries i.e. the read address is not pointing to an address not in the memory. Use the signals 're' and 'ra'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (re |-> ra < entries)\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-73", "problem": "write address is not greater than number of entries i.e. the write address is not pointing to an address not in the memory. Use the signals 'we' and 'wa'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (we |-> wa < entries)\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-74", "problem": "write through violation, where a read from and a write to the same address happen in same cycle, does not occur. Use the signals 'we', 'wa', 're' and 'ra'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (we && re |-> !(wa == ra))\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-75", "problem": "write after write cases, where writes to the same address happen before a read, does not occur. Use the signals 'we', 'wa', 'symbolic_constant_a', and 'addr_aw_seen'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n     (addr_aw_seen |-> !(we && (wa == symbolic_constant_a)))\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-76", "problem": "read after read cases, where read to the same address happen before a write, does not occur. Use the signals 're', 'ra', 'symbolic_constant_a', and 'addr_ar_seen'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (addr_ar_seen |-> !(re && (ra == symbolic_constant_a)))\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-77", "problem": "read before write cases, where read to the same address happen before a write, does not occur. Use the signals 're', 'ra', 'symbolic_constant_a', and 'addr_first_aw_seen'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (!addr_first_aw_seen |-> !(re && (ra == symbolic_constant_a)))\n);", "signals_for_validity": null}
{"name": "FVEval-NL2SVA-Human-78", "problem": "max latency between a write and following read is within the specified write-read latency threshold. Use the signal 'latency_cnt'.", "testbench": "module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);\n\n  \n    parameter   addr_width = 1;\n    parameter   data_width = 1;\n    parameter   entries = 1;\n    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check\n\n\nparameter tb_max_length_width = $clog2(wr_latency);\n\ninput    clk,reset_;\ninput    we,re;\ninput [addr_width-1:0] wa,ra;\ninput [data_width-1:0] wd,rd;\ninput    stall;\n\nwire tb_reset;\nassign tb_reset = (reset_ == 1'b0);\n\n\nwire [addr_width-1:0] symbolic_constant_a;\nasum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)\n  ($stable(symbolic_constant_a))\n);\n\nreg addr_ar_seen;\nreg addr_aw_seen;\nreg addr_first_aw_seen;\nreg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       \n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd1;    \n  end else if (re && (ra == symbolic_constant_a)) begin\n    addr_aw_seen <= 1'd0;    \n  end\nend\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_ar_seen <= 1'd0;\n  end else if (we && (re == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd1;    \n  end else if (re && (we == symbolic_constant_a)) begin\n    addr_ar_seen <= 1'd0;    \n  end\nend\n\nalways @(posedge clk) begin\n  if(!reset_) begin\n    addr_first_aw_seen <= 1'd0;\n  end else if (we && (wa == symbolic_constant_a)) begin\n    addr_first_aw_seen <= 1'd1;\n  end\nend\n\nalways @(posedge clk) begin\n    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;\nend\n\n\nendmodule", "ground_truth": "asrt: assert property (@(posedge clk) disable iff (tb_reset)\n    (latency_cnt <= wr_latency)\n);", "signals_for_validity": null}
